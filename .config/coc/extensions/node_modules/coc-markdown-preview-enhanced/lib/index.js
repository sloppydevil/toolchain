"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/isbinaryfile/lib/index.js
var require_lib = __commonJS({
  "node_modules/isbinaryfile/lib/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBinaryFileSync = exports.isBinaryFile = void 0;
    var fs2 = require("fs");
    var util_1 = require("util");
    var statAsync = util_1.promisify(fs2.stat);
    var openAsync = util_1.promisify(fs2.open);
    var closeAsync = util_1.promisify(fs2.close);
    var MAX_BYTES = 512;
    var Reader = class {
      constructor(fileBuffer, size) {
        this.fileBuffer = fileBuffer;
        this.size = size;
        this.offset = 0;
        this.error = false;
      }
      hasError() {
        return this.error;
      }
      nextByte() {
        if (this.offset === this.size || this.hasError()) {
          this.error = true;
          return 255;
        }
        return this.fileBuffer[this.offset++];
      }
      next(len) {
        const n = new Array();
        for (let i = 0; i < len; i++) {
          n[i] = this.nextByte();
        }
        return n;
      }
    };
    function readProtoVarInt(reader) {
      let idx = 0;
      let varInt = 0;
      while (!reader.hasError()) {
        const b = reader.nextByte();
        varInt = varInt | (b & 127) << 7 * idx;
        if ((b & 128) === 0) {
          break;
        }
        idx++;
      }
      return varInt;
    }
    function readProtoMessage(reader) {
      const varInt = readProtoVarInt(reader);
      const wireType = varInt & 7;
      switch (wireType) {
        case 0:
          readProtoVarInt(reader);
          return true;
        case 1:
          reader.next(8);
          return true;
        case 2:
          const len = readProtoVarInt(reader);
          reader.next(len);
          return true;
        case 5:
          reader.next(4);
          return true;
      }
      return false;
    }
    function isBinaryProto(fileBuffer, totalBytes) {
      const reader = new Reader(fileBuffer, totalBytes);
      let numMessages = 0;
      while (true) {
        if (!readProtoMessage(reader) && !reader.hasError()) {
          return false;
        }
        if (reader.hasError()) {
          break;
        }
        numMessages++;
      }
      return numMessages > 0;
    }
    function isBinaryFile2(file, size) {
      return __awaiter(this, void 0, void 0, function* () {
        if (isString(file)) {
          const stat2 = yield statAsync(file);
          isStatFile(stat2);
          const fileDescriptor = yield openAsync(file, "r");
          const allocBuffer = Buffer.alloc(MAX_BYTES);
          return new Promise((fulfill, reject) => {
            fs2.read(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0, (err, bytesRead, _) => {
              closeAsync(fileDescriptor);
              if (err) {
                reject(err);
              } else {
                fulfill(isBinaryCheck(allocBuffer, bytesRead));
              }
            });
          });
        } else {
          if (size === void 0) {
            size = file.length;
          }
          return isBinaryCheck(file, size);
        }
      });
    }
    exports.isBinaryFile = isBinaryFile2;
    function isBinaryFileSync(file, size) {
      if (isString(file)) {
        const stat2 = fs2.statSync(file);
        isStatFile(stat2);
        const fileDescriptor = fs2.openSync(file, "r");
        const allocBuffer = Buffer.alloc(MAX_BYTES);
        const bytesRead = fs2.readSync(fileDescriptor, allocBuffer, 0, MAX_BYTES, 0);
        fs2.closeSync(fileDescriptor);
        return isBinaryCheck(allocBuffer, bytesRead);
      } else {
        if (size === void 0) {
          size = file.length;
        }
        return isBinaryCheck(file, size);
      }
    }
    exports.isBinaryFileSync = isBinaryFileSync;
    function isBinaryCheck(fileBuffer, bytesRead) {
      if (bytesRead === 0) {
        return false;
      }
      let suspiciousBytes = 0;
      const totalBytes = Math.min(bytesRead, MAX_BYTES);
      if (bytesRead >= 3 && fileBuffer[0] === 239 && fileBuffer[1] === 187 && fileBuffer[2] === 191) {
        return false;
      }
      if (bytesRead >= 4 && fileBuffer[0] === 0 && fileBuffer[1] === 0 && fileBuffer[2] === 254 && fileBuffer[3] === 255) {
        return false;
      }
      if (bytesRead >= 4 && fileBuffer[0] === 255 && fileBuffer[1] === 254 && fileBuffer[2] === 0 && fileBuffer[3] === 0) {
        return false;
      }
      if (bytesRead >= 4 && fileBuffer[0] === 132 && fileBuffer[1] === 49 && fileBuffer[2] === 149 && fileBuffer[3] === 51) {
        return false;
      }
      if (totalBytes >= 5 && fileBuffer.slice(0, 5).toString() === "%PDF-") {
        return true;
      }
      if (bytesRead >= 2 && fileBuffer[0] === 254 && fileBuffer[1] === 255) {
        return false;
      }
      if (bytesRead >= 2 && fileBuffer[0] === 255 && fileBuffer[1] === 254) {
        return false;
      }
      for (let i = 0; i < totalBytes; i++) {
        if (fileBuffer[i] === 0) {
          return true;
        } else if ((fileBuffer[i] < 7 || fileBuffer[i] > 14) && (fileBuffer[i] < 32 || fileBuffer[i] > 127)) {
          if (fileBuffer[i] > 193 && fileBuffer[i] < 224 && i + 1 < totalBytes) {
            i++;
            if (fileBuffer[i] > 127 && fileBuffer[i] < 192) {
              continue;
            }
          } else if (fileBuffer[i] > 223 && fileBuffer[i] < 240 && i + 2 < totalBytes) {
            i++;
            if (fileBuffer[i] > 127 && fileBuffer[i] < 192 && fileBuffer[i + 1] > 127 && fileBuffer[i + 1] < 192) {
              i++;
              continue;
            }
          }
          suspiciousBytes++;
          if (i >= 32 && suspiciousBytes * 100 / totalBytes > 10) {
            return true;
          }
        }
      }
      if (suspiciousBytes * 100 / totalBytes > 10) {
        return true;
      }
      if (suspiciousBytes > 1 && isBinaryProto(fileBuffer, totalBytes)) {
        return true;
      }
      return false;
    }
    function isString(x) {
      return typeof x === "string";
    }
    function isStatFile(stat2) {
      if (!stat2.isFile()) {
        throw new Error(`Path provided was not a file!`);
      }
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(src_exports);
var import_mume3 = require("@shd101wyy/mume");
var import_isbinaryfile = __toESM(require_lib());
var import_coc20 = require("coc.nvim");
var import_path2 = __toESM(require("path"));

// src/image-helper.ts
var import_mume = require("@shd101wyy/mume");
var import_coc17 = require("coc.nvim");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));

// node_modules/coc-helper/lib/esm/index.js
var import_coc15 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/FloatingWindow.js
var import_coc11 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/notifier.js
var import_coc5 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/collection.js
var compactI = (arr) => arr.filter((it) => it !== void 0 && it !== null);

// node_modules/coc-helper/lib/esm/util/config.js
var import_coc2 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/text.js
var import_coc = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/env.js
var isWindows = process.platform === "win32";
var isMacintosh = process.platform === "darwin";
var isLinux = process.platform === "linux";
var isTest = process.env.NODE_ENV === "test";

// node_modules/coc-helper/lib/esm/util/text.js
async function displayWidth(content) {
  return await import_coc.workspace.nvim.call("strdisplaywidth", [content]);
}

// node_modules/coc-helper/lib/esm/util/log.js
var import_coc3 = require("coc.nvim");
var import_util = __toESM(require("util"));
var levelList = [
  "trace",
  "debug",
  "info",
  "warn",
  "error",
  "fatal",
  "off"
];
var levelErrorNum = levelList.indexOf("error");
function formatDate(date) {
  return `${date.toLocaleString()} ${date.getMilliseconds().toString().padStart(3, "0")}`;
}
var HelperLogger = class {
  constructor(channelName) {
    this.channelName = channelName;
    this.timeMarkers = /* @__PURE__ */ new Map();
    this.levelStatus = "trace";
    this.levelNumber = levelList.indexOf(this.levelStatus);
    this.appendLine = (line) => {
      this.outputChannel.appendLine(line);
    };
    this.appendErrorLine = (line) => {
      if (isTest) {
        console.error(line);
      } else {
        void import_coc3.window.showErrorMessage(line);
      }
    };
    this.log = (levelName, data) => {
      var _a, _b;
      const levelNum = levelList[levelName];
      if (levelNum < this.levelNumber) {
        return;
      }
      const prefix = `[${formatDate(/* @__PURE__ */ new Date())}] [${levelName}]: `;
      if (data instanceof Error) {
        this.appendLine(`${prefix}${(_a = data.stack) !== null && _a !== void 0 ? _a : data.toString()}`);
        this.appendErrorLine(data.message);
        if (isTest) {
          console.error((_b = data.stack) !== null && _b !== void 0 ? _b : data.toString());
        }
        return;
      }
      this.appendLine(`${prefix}${data}`);
      if (levelNum > levelErrorNum) {
        this.appendErrorLine(data);
      }
    };
    this.trace = (line) => {
      this.log("trace", line);
    };
    this.debug = (line) => {
      this.log("debug", line);
    };
    this.info = (line) => {
      this.log("info", line);
    };
    this.warn = (line) => {
      this.log("warn", line);
    };
    this.error = (data) => {
      if (!(data instanceof Error)) {
        data = new Error(data);
      }
      this.log("error", data);
    };
    this.fatal = (data) => {
      this.log("fatal", data);
    };
    this.prettyPrint = (...data) => {
      this.info(prettyObject(...data));
      this.appendErrorLine(`[${formatDate(/* @__PURE__ */ new Date())}] ${prettyObject(...data)}`);
    };
  }
  /**
   * Default level is 'trace'
   */
  set level(level) {
    this.levelStatus = level;
    this.levelNumber = levelList[level];
  }
  get level() {
    return this.levelStatus;
  }
  dispose() {
    var _a;
    (_a = this.outputChannel_) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  get outputChannel() {
    if (!this.outputChannel_) {
      this.outputChannel_ = import_coc3.window.createOutputChannel(this.channelName);
    }
    return this.outputChannel_;
  }
  time(label = "default") {
    this.timeMarkers.set(label, (/* @__PURE__ */ new Date()).valueOf());
  }
  /**
   * @returns milliseconds
   */
  timeElapsed(label = "default") {
    const time = this.timeMarkers.get(label);
    if (time !== void 0) {
      return (/* @__PURE__ */ new Date()).valueOf() - time;
    }
  }
  timeLog(label = "default") {
    const time = this.timeElapsed(label);
    if (time !== void 0) {
      this.appendLine(`${label}: ${time} ms`);
    }
  }
  measureTime(task) {
    const time = (/* @__PURE__ */ new Date()).valueOf();
    const result = task();
    if (result instanceof Promise) {
      return result.then((r) => {
        return [r, (/* @__PURE__ */ new Date()).valueOf() - time];
      });
    }
    return [result, (/* @__PURE__ */ new Date()).valueOf() - time];
  }
  measureTask(task, label = "default", level = "info") {
    const response = this.measureTime(task);
    if (!("then" in response)) {
      const [result, time] = response;
      this.log(level, `[measureTask] ${label}: ${time} ms`);
      return result;
    }
    return response.then(([result, time]) => {
      this.log(level, `${label}: ${time} ms`);
      return result;
    });
  }
  /**
   * Wrap the async function and catch the error
   */
  asyncCatch(fn) {
    return async (...args) => {
      try {
        return await fn(...args);
      } catch (e) {
        this.error(e);
      }
    };
  }
};
var helperLogger = new HelperLogger("coc-helper");
function prettyObject(...data) {
  return data.map((d) => import_util.default.inspect(d)).join(" ");
}

// node_modules/coc-helper/lib/esm/_package.json
var package_default = {
  name: "coc-helper",
  version: "0.16.3",
  description: "Helpers for coc.nvim",
  module: "lib/esm/index.js",
  main: "lib/cjs/index.js",
  homepage: "https://github.com/weirongxu/coc-helper",
  repository: "git@github.com:weirongxu/coc-helper.git",
  author: "Weirong Xu <weirongxu.raidou@gmail.com>",
  license: "MIT",
  files: [
    "lib",
    "jest.config.js",
    "tests"
  ],
  scripts: {
    clean: "shx rm -rf lib",
    "copy:pkg": "shx cp package.json src/_package.json",
    "build:esm": "tsc -p ./tsconfig.prod.json --module es2020 --outDir lib/esm",
    "build:cjs": "tsc -p ./tsconfig.prod.json --module commonjs --outDir lib/cjs",
    build: "run-s clean copy:pkg build:esm build:cjs",
    lint: "eslint src --ext ts",
    prepare: "run-s clean build",
    unittest: "jest",
    test: "run-s copy:pkg lint unittest"
  },
  engines: {
    coc: "^0.0.77"
  },
  activationEvents: [
    "*"
  ],
  prettier: {
    singleQuote: true,
    printWidth: 80,
    semi: true,
    trailingComma: "all"
  },
  peerDependencies: {
    "coc.nvim": "*"
  },
  devDependencies: {
    "@chemzqm/neovim": "^6.1.1",
    "@raidou/eslint-config-base": "^1.6.0",
    "@types/eslint": "^8.4.10",
    "@types/jest": "^29.2.5",
    "@types/node": "^18.11.18",
    "@types/rimraf": "^3.0.2",
    "@types/uuid": "^9.0.0",
    "coc.nvim": "0.0.83-next.9",
    eslint: "^8.31.0",
    jest: "^29.3.1",
    log4js: "^6.7.1",
    "npm-run-all": "^4.1.5",
    prettier: "^2.8.2",
    shx: "^0.3.4",
    "ts-jest": "^29.0.4",
    typescript: "^4.9.4"
  },
  dependencies: {
    rimraf: "^3.0.2",
    uuid: "^9.0.0"
  }
};

// node_modules/coc-helper/lib/esm/util/version.js
var version = package_default.version;
var versionName = version.replace(/[.-]/g, "_");

// node_modules/coc-helper/lib/esm/util/vim.js
var import_coc4 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/notifier.js
var Notifier = class _Notifier {
  static async run(notifier) {
    if (!notifier) {
      return;
    }
    if ("then" in notifier) {
      const awaitedNotifier = await notifier;
      if (awaitedNotifier) {
        return awaitedNotifier.run();
      }
    } else {
      return notifier.run();
    }
  }
  static notifyAll(lazyNotifies) {
    for (const n of lazyNotifies) {
      if (n) {
        n.notify();
      }
    }
  }
  static async runAll(notifierPromises) {
    const notifiers = await Promise.all(notifierPromises);
    import_coc5.workspace.nvim.pauseNotification();
    this.notifyAll(notifiers);
    return import_coc5.workspace.nvim.resumeNotification();
  }
  static combine(notifiers) {
    const compactedNotifiers = compactI(notifiers);
    if (compactedNotifiers.length < 1) {
      return _Notifier.noop();
    }
    if (compactedNotifiers.length === 1) {
      return compactedNotifiers[0];
    }
    return compactedNotifiers.reduce((ret, cur) => ret.concat(cur), _Notifier.noop());
  }
  static noop() {
    return this.create(() => {
    });
  }
  static create(notify) {
    return new _Notifier(notify);
  }
  constructor(notify) {
    this.notifyFns = [];
    this.notifyFns.push(notify);
  }
  async run() {
    return _Notifier.runAll([this]);
  }
  notify() {
    for (const fn of this.notifyFns) {
      fn();
    }
  }
  concat(notifier) {
    this.notifyFns.push(...notifier.notifyFns);
    return this;
  }
};

// node_modules/coc-helper/lib/esm/modules/floating.js
var import_coc8 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/VimModule.js
var import_coc6 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/util/module.js
var globalModuleIdSym = Symbol("helper_module_max_id");
function getModuleId(key) {
  if (!(globalModuleIdSym in global)) {
    global[globalModuleIdSym] = {};
  }
  const moduleIds = global[globalModuleIdSym];
  if (!(key in moduleIds)) {
    moduleIds[key] = 0;
  }
  moduleIds[key] += 1;
  return moduleIds[key];
}

// node_modules/coc-helper/lib/esm/VimModule.js
var mid = getModuleId("VimModule");
var globalKey = `coc_helper_module_m${mid}_v${versionName}`;
var globalVariable = `g:${globalKey}`;
var callFunc = `CocHelperCallFn_m${mid}_v${versionName}`;
var declareVar = `CocHelperCallVar_m${mid}_v${versionName}`;
function filterLineCont(content) {
  return content.replace(/\n\s*\\/g, "");
}
var VimModule = class _VimModule {
  static async init(context) {
    this.inited = true;
    await import_coc6.workspace.nvim.call("execute", `
        if !exists('${globalVariable}')
          let ${globalVariable} = {}
        endif

        function! ${callFunc}(module_key, method_name, args)
          try
            return call(${globalVariable}[a:module_key][a:method_name], a:args)
          catch
            let ex = v:exception
            let msg = printf('error when call %s.%s.%s, args: [%s]', '${globalVariable}', a:module_key, a:method_name, join(a:args, ','))
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction

        function! ${declareVar}(module_key, var_name, expression)
          try
            let ${globalVariable}[a:module_key][a:var_name] = eval(a:expression)
          catch
            let ex = v:exception
            let msg = printf('error when declare %s.%s.%s, expression: %s', '${globalVariable}', a:module_key, a:var_name, a:expression)
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction
      `);
    const queue = [...this.initQueue];
    while (queue.length) {
      const it = queue.shift();
      try {
        await it.fn(context);
      } catch (error) {
        helperLogger.error(error);
      }
      if (this.initAfterQueue.length) {
        queue.push(...this.initAfterQueue);
        this.initAfterQueue = [];
      }
    }
  }
  static registerInit(description, fn) {
    if (!this.inited) {
      this.initQueue.push({ description, fn });
    } else {
      this.initAfterQueue.push({ description, fn });
    }
  }
  static create(moduleName, cb) {
    const id = getModuleId("VimModule.module");
    const moduleKey = `${id}_${moduleName}`;
    const vMod = new _VimModule(moduleKey);
    let mod = void 0;
    function initedMod() {
      if (!mod) {
        mod = cb(vMod);
      }
      return mod;
    }
    _VimModule.registerInit(`module ${moduleKey}`, async () => {
      await import_coc6.workspace.nvim.call("execute", `
          if !exists('${globalVariable}.${moduleKey}')
            let ${globalVariable}.${moduleKey} = {}
          endif
        `);
      initedMod();
    });
    return new Proxy({}, {
      get(_o, key) {
        return Reflect.get(initedMod(), key);
      },
      has(_o, key) {
        return key in initedMod();
      },
      ownKeys() {
        return Object.keys(initedMod());
      }
    });
  }
  constructor(moduleKey) {
    this.moduleKey = moduleKey;
  }
  registerInit(description, fn) {
    if (typeof description === "string") {
      return _VimModule.registerInit(description, fn);
    } else {
      return this.registerInit("", description);
    }
  }
  fn(fnName, getContent) {
    const { nvim } = import_coc6.workspace;
    const name = `${globalVariable}.${this.moduleKey}.${fnName}`;
    const content = getContent({ name });
    this.registerInit(`fn ${name}`, async () => {
      helperLogger.debug(`declare fn ${name}`);
      await nvim.call("execute", [filterLineCont(content)]);
    });
    return {
      name,
      inlineCall: (argsExpression = "") => `${callFunc}('${this.moduleKey}', '${fnName}', [${argsExpression}])`,
      call: (...args) => {
        helperLogger.debug(`call ${name}`);
        return nvim.call(callFunc, [
          this.moduleKey,
          fnName,
          args
        ]);
      },
      callNotify: (...args) => {
        helperLogger.debug(`callNotify ${name}`);
        return nvim.call(callFunc, [this.moduleKey, fnName, args], true);
      },
      callNotifier: (...args) => {
        helperLogger.debug(`callNotifier ${name}`);
        return Notifier.create(() => {
          nvim.call(callFunc, [this.moduleKey, fnName, args], true);
        });
      }
    };
  }
  var(varName, expression) {
    const { nvim } = import_coc6.workspace;
    const name = `${globalVariable}.${this.moduleKey}.${varName}`;
    this.registerInit(`var ${name}`, async () => {
      helperLogger.debug(`declare var ${name}`);
      await nvim.call(declareVar, [
        this.moduleKey,
        varName,
        filterLineCont(expression)
      ]);
    });
    return {
      name,
      inline: name,
      get: () => {
        return nvim.eval(name);
      },
      set: async (expression2) => {
        await nvim.call(declareVar, [
          this.moduleKey,
          varName,
          filterLineCont(expression2)
        ]);
      },
      setNotify: (expression2) => {
        nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression2)], true);
      },
      setNotifier: (expression2) => {
        return Notifier.create(() => {
          nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression2)], true);
        });
      }
    };
  }
};
VimModule.inited = false;
VimModule.initQueue = [];
VimModule.initAfterQueue = [];

// node_modules/coc-helper/lib/esm/modules/buf.js
var import_coc7 = require("coc.nvim");
var bufModule = VimModule.create("buf", (m) => {
  const isNvim = import_coc7.workspace.isNvim;
  const createByName = m.fn("create_by_name", ({ name }) => `
      function! ${name}(name) abort
        return bufadd(a:name)
      endfunction
    `);
  return {
    createByName,
    create: m.fn("create", ({ name }) => isNvim ? `
          function! ${name}(...) abort
            let name = get(a:000, 0, '')
            if name is ''
              return nvim_create_buf(v:false, v:true)
            else
              return ${createByName.inlineCall("name")}
            endif
          endfunction
        ` : `
          function! ${name}(...) abort
            let name = get(a:000, 0, '')
            return ${createByName.inlineCall("name")}
          endfunction
        `)
  };
});

// node_modules/coc-helper/lib/esm/modules/floating.js
var floatingModule = VimModule.create("float", (m) => {
  const isNvim = import_coc8.workspace.isNvim;
  const initExecute = m.fn("init_execute", ({ name }) => `
      function! ${name}(ctx, inited_execute) abort
        execute a:inited_execute
      endfunction
    `);
  const openWin = m.fn("open_win", ({ name }) => isNvim ? `
        function! ${name}(bufnr, focus, win_config, win_hl, inited_execute) abort
          noau let winid = nvim_open_win(a:bufnr, a:focus, a:win_config)
          if !empty(a:win_hl)
            call nvim_win_set_option(winid, 'winhl', a:win_hl)
          endif
          if !empty(a:inited_execute)
            call ${initExecute.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}
          endif
          return winid
        endfunction
      ` : `
        function! ${name}(bufnr, focus, win_config, win_hl, inited_execute) abort
          let winid = popup_create(a:bufnr, a:win_config)
          call ${initExecute.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}

          return winid
        endfunction
      `);
  return {
    create: m.fn("create", ({ name }) => isNvim ? `
            function! ${name}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${bufModule.create.inlineCall("a:name")}
              call ${initExecute.inlineCall("{'bufnr': bufnr}, a:inited_execute")}

              let border_bufnr = v:null
              if a:has_border_buf
                let border_bufnr = nvim_create_buf(v:false, v:true)
                call ${initExecute.inlineCall("{'bufnr': border_bufnr}, a:border_inited_execute")}
              endif
              return [bufnr, border_bufnr]
            endfunction
          ` : `
            function! ${name}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${bufModule.create.inlineCall("a:name")}
              call ${initExecute.inlineCall("{'bufnr': bufnr}, a:inited_execute")}
              return [bufnr, v:null]
            endfunction
          `),
    open: m.fn("open", ({ name }) => `
        function! ${name}(bufnr, win_config, inited_execute, border_bufnr, border_win_config, border_inited_execute, focus, win_hl) abort
          let winid = ${openWin.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, a:inited_execute")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${openWin.inlineCall("a:border_bufnr, v:false, a:border_win_config, a:win_hl, a:border_inited_execute")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),
    resume: m.fn("resume", ({ name }) => `
        function! ${name}(bufnr, win_config, border_bufnr, border_win_config, focus, win_hl) abort
          let winid = ${openWin.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, ''")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${openWin.inlineCall("border_bufnr, v:false, a:border_win_config, a:win_hl, ''")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),
    update: m.fn("update", ({ name }) => isNvim ? `
          function! ${name}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call nvim_win_set_config(winid, a:win_config)
            if !empty(a:win_hl)
              call nvim_win_set_option(winid, 'winhl', a:win_hl)
            endif
            if has('nvim')
              redraw!
            endif

            if a:border_bufnr
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              if border_winid
                call nvim_win_set_config(border_winid, a:border_win_config)
                if !empty(a:win_hl)
                  call nvim_win_set_option(border_winid, 'winhl', a:win_hl)
                endif
                if has('nvim')
                  redraw!
                endif
              endif
            endif
          endfunction
        ` : `
          function! ${name}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call popup_setoptions(winid, a:win_config)
          endfunction
        `),
    winid: m.fn("winid", ({ name }) => `
        function! ${name}(bufnr) abort
          let id = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
          let nr = win_id2win(id)
          return nr is 0 ? v:null : id
        endfunction
      `),
    borderWinid: m.fn("border_winid", ({ name }) => `
        function! ${name}(bufnr) abort
          return getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
        endfunction
      `),
    close: m.fn("close", ({ name }) => isNvim ? `
            function! ${name}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              try
                if winid
                  call nvim_win_close(winid, v:true)
                endif
                if border_winid
                  call nvim_win_close(border_winid, v:true)
                endif
              catch
              endtry
            endfunction
          ` : `
            function! ${name}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              try
                if winid
                  call popup_close(winid)
                endif
              catch
              endtry
            endfunction
          `)
  };
});

// node_modules/coc-helper/lib/esm/modules/util.js
var import_coc9 = require("coc.nvim");
var utilModule = VimModule.create("util", (m) => {
  const isNvim = import_coc9.workspace.isNvim;
  return {
    globalCursorPosition: m.fn("global_cursor_position", ({ name }) => `
        function! ${name}()
          let nr = winnr()
          let [row, col] = win_screenpos(nr)
          return [row + winline() - 2, col + wincol() - 2]
        endfunction
      `),
    isFloat: m.fn("is_float", ({ name }) => isNvim ? `
          function! ${name}(winnr) abort
            if !exists('*nvim_win_get_config')
              return v:false
            endif
            let winid = win_getid(a:winnr)
            return nvim_win_get_config(winid)['relative'] != ''
          endfunction
        ` : `
          function! ${name}(winnr) abort
            return v:false
          endfunction
        `),
    closeWinByBufnr: m.fn("close_win_by_bufnr", ({ name }) => `
        if exists('*nvim_win_close')
          function! ${name}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winid = bufwinid(bufnr)
                if winid >= 0
                  call nvim_win_close(winid, v:true)
                endif
              catch
              endtry
            endfor
          endfunction
        else
          function! ${name}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winnr = bufwinnr(bufnr)
                if winnr >= 0
                  execute winnr . 'wincmd c'
                endif
              catch
              endtry
            endfor
          endfunction
        endif
      `),
    runCocCmd: m.fn("run_coc_cmd", ({ name }) => `
        function! ${name}(name, ...) abort
          return call('CocAction', extend(['runCommand', a:name], a:000))
        endfunction
      `),
    runCocCmdAsync: m.fn("run_coc_cmd_async", ({ name }) => `
        function! ${name}(name, ...) abort
          return call('CocActionAsync', extend(['runCommand', a:name], a:000))
        endfunction
      `)
  };
});

// node_modules/coc-helper/lib/esm/FloatingUtil.js
var import_coc10 = require("coc.nvim");
var defaultBorderChars = ["\u2500", "\u2502", "\u2500", "\u2502", "\u250C", "\u2510", "\u2518", "\u2514"];
var defaultWinHl = "CocHelperNormalFloat";
var defaultWinHlNC = "CocHelperNormalFloatNC";
var defaultBorderWinHl = "CocHelperNormalFloatBorder";
var FloatingUtil = class {
  constructor(srcId) {
    this.srcId = srcId;
  }
  async createContext(options) {
    var _a, _b;
    return (_a = options.context) !== null && _a !== void 0 ? _a : {
      lines: import_coc10.workspace.env.lines,
      columns: import_coc10.workspace.env.columns - import_coc10.workspace.env.cmdheight - 1,
      globalCursorPosition: await utilModule.globalCursorPosition.call(),
      title: options.title ? {
        text: options.title,
        width: await displayWidth(options.title)
      } : { text: "", width: 0 },
      borderEnabled: !!options.border,
      border: this.extendEdges((_b = options.border) === null || _b === void 0 ? void 0 : _b.map((b) => typeof b === "boolean" ? 1 : b)),
      paddingEnabled: !!options.padding,
      padding: this.extendEdges(options.padding)
    };
  }
  getCenterPos(ctx, box) {
    const [, , width, height] = box;
    const top = Math.floor((ctx.lines - height) / 2);
    const left = Math.floor((ctx.columns - width) / 2);
    return [top, left];
  }
  getPosForAround(ctx, size, cursorPosition, preferAbove = false) {
    const columns = ctx.columns;
    const lines = ctx.lines - 1;
    const [width, height] = size;
    let [top, left] = cursorPosition;
    if (preferAbove) {
      if (top - height < 0) {
        top += 1;
      } else {
        top -= height;
      }
    } else {
      if (top + height >= lines) {
        top -= height;
      } else {
        top += 1;
      }
    }
    if (left + width >= columns) {
      left -= width - 1;
    }
    return [top, left];
  }
  /**
   * Extend around number to 4
   */
  extendEdges(edges) {
    var _a, _b, _c, _d;
    if (!edges) {
      return [0, 0, 0, 0];
    }
    const top = (_a = edges[0]) !== null && _a !== void 0 ? _a : 1;
    const right = (_b = edges[1]) !== null && _b !== void 0 ? _b : top;
    const bottom = (_c = edges[2]) !== null && _c !== void 0 ? _c : top;
    const left = (_d = edges[3]) !== null && _d !== void 0 ? _d : right;
    return [top, right, bottom, left];
  }
  /**
   * Change window box by around edges
   */
  changeBoxByEdgesList(box, edgesList) {
    let retBox = [...box];
    for (const edges of edgesList) {
      retBox = this.changeBoxByEdges(retBox, edges);
    }
    return retBox;
  }
  /**
   * Change window box by around edge
   */
  changeBoxByEdges(box, edges) {
    if (!edges) {
      return box;
    }
    const [wTop, wRight, wBottom, wLeft] = edges;
    let [top, left, width, height] = box;
    top -= wTop;
    left -= wLeft;
    width += wLeft + wRight;
    height += wTop + wBottom;
    return [top, left, width, height];
  }
  getBoxSizes(ctx, options, updateCursorPosition) {
    var _a, _b;
    const [top, left] = [(_a = options.top) !== null && _a !== void 0 ? _a : 0, (_b = options.left) !== null && _b !== void 0 ? _b : 0];
    const width = Math.max(options.width, ctx.title.width);
    const contentBox = [0, 0, width, options.height];
    const paddingBox = this.changeBoxByEdges(contentBox, ctx.padding);
    const borderBox = this.changeBoxByEdges(paddingBox, ctx.border);
    let fullPos;
    if (options.relative === "center") {
      fullPos = this.getCenterPos(ctx, borderBox);
    } else {
      const cursorPosition = !updateCursorPosition && this.storeCursorPosition ? this.storeCursorPosition : ctx.globalCursorPosition;
      if (options.relative === "cursor") {
        fullPos = cursorPosition;
      } else if (options.relative === "cursor-around") {
        fullPos = this.getPosForAround(ctx, [borderBox[2], borderBox[3]], cursorPosition);
      } else {
        fullPos = [top, left];
      }
      this.storeCursorPosition = cursorPosition;
    }
    [borderBox[0], borderBox[1]] = [fullPos[0], fullPos[1]];
    [paddingBox[0], paddingBox[1]] = [
      borderBox[0] + ctx.border[0],
      borderBox[1] + ctx.border[3]
    ];
    [contentBox[0], contentBox[1]] = [
      paddingBox[0] + ctx.padding[0],
      paddingBox[1] + ctx.padding[3]
    ];
    return {
      contentBox,
      paddingBox,
      borderBox
    };
  }
  vimWinConfig(ctx, options, updateCursorPosition) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [top, left, width, height] = [
      (_a = options.top) !== null && _a !== void 0 ? _a : 0,
      (_b = options.left) !== null && _b !== void 0 ? _b : 0,
      options.width,
      options.height
    ];
    const config = {
      line: 0,
      col: 0,
      zindex: ((_c = options.borderOnly) !== null && _c !== void 0 ? _c : false) ? 1 : 100,
      minwidth: width,
      minheight: height,
      maxwidth: width,
      maxheight: height
    };
    if (options.relative === "center") {
      config.pos = "center";
    } else {
      const cursorPosition = !updateCursorPosition && this.storeCursorPosition ? this.storeCursorPosition : ctx.globalCursorPosition;
      if (options.relative === "cursor") {
        [config.line, config.col] = cursorPosition;
      } else if (options.relative === "cursor-around") {
        const box = this.changeBoxByEdgesList([top, left, width, height], [ctx.padding, ctx.border]);
        [config.line, config.col] = this.getPosForAround(ctx, [box[2], box[3]], cursorPosition);
      } else {
        [config.line, config.col] = [top, left];
      }
      this.storeCursorPosition = cursorPosition;
      config.line += 1;
      config.col += 1;
    }
    const topOffset = (_d = options.topOffset) !== null && _d !== void 0 ? _d : 0;
    const leftOffset = (_e = options.leftOffset) !== null && _e !== void 0 ? _e : 0;
    config.line += topOffset;
    config.col += leftOffset;
    if (options.maxWidth) {
      config.maxwidth = options.maxWidth;
    }
    if (options.maxHeight) {
      config.maxheight = options.maxHeight;
    }
    config.highlight = (_f = options.winHl) !== null && _f !== void 0 ? _f : defaultWinHl;
    if (options.padding) {
      config.padding = options.padding;
    }
    if (ctx.borderEnabled) {
      config.border = ctx.border;
      if (config.border[0]) {
        if (ctx.title.width) {
          config.title = ctx.title.text;
        }
        config.close = "button";
      }
      config.borderchars = (_g = options.borderChars) !== null && _g !== void 0 ? _g : defaultBorderChars;
      config.borderhighlight = [(_h = options.borderWinHl) !== null && _h !== void 0 ? _h : defaultBorderWinHl];
    }
    return config;
  }
  nvimWinConfig(ctx, options, updateCursorPosition) {
    var _a, _b, _c;
    const { contentBox, borderBox } = this.getBoxSizes(ctx, options, updateCursorPosition);
    const topOffset = (_a = options.topOffset) !== null && _a !== void 0 ? _a : 0;
    const leftOffset = (_b = options.leftOffset) !== null && _b !== void 0 ? _b : 0;
    const winConfig = {
      relative: "editor",
      row: contentBox[0] + topOffset,
      col: contentBox[1] + leftOffset,
      width: contentBox[2],
      height: contentBox[3],
      focusable: (_c = options.focusable) !== null && _c !== void 0 ? _c : true
    };
    let winConfigBorder;
    if (borderBox) {
      winConfigBorder = {
        relative: "editor",
        row: borderBox[0] + topOffset,
        col: borderBox[1] + leftOffset,
        width: borderBox[2],
        height: borderBox[3],
        focusable: false
      };
    }
    return [winConfig, winConfigBorder];
  }
  winConfig(ctx, options, updateCursorPosition = true) {
    return import_coc10.workspace.isVim ? [this.vimWinConfig(ctx, options, updateCursorPosition), void 0] : this.nvimWinConfig(ctx, options, updateCursorPosition);
  }
  getRenderBorderData(ctx, options, winOptions) {
    var _a, _b, _c, _d, _e, _f;
    const title = (_b = (_a = ctx.title) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    const titleWidth = (_d = (_c = ctx.title) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 0;
    if (!ctx.borderEnabled) {
      return;
    }
    const [bTop, bRight, bBottom, bLeft] = ctx.border;
    let [cTop, cRight, cBottom, cLeft, cTopleft, cTopright, cBotright, cBotleft] = (_e = options.borderChars) !== null && _e !== void 0 ? _e : defaultBorderChars;
    if (!bTop) {
      cTop = "";
    }
    if (!bRight) {
      cRight = "";
    }
    if (!bBottom) {
      cBottom = "";
    }
    if (!bLeft) {
      cLeft = "";
    }
    if (!bTop || !bLeft) {
      cTopleft = "";
    }
    if (!bTop || !bRight) {
      cTopright = "";
    }
    if (!bBottom || !bLeft) {
      cBotleft = "";
    }
    if (!bBottom || !bRight) {
      cBotright = "";
    }
    const width = winOptions[0];
    const height = winOptions[1];
    const spaceWidth = width - bLeft - bRight;
    const spaceHeight = height - bTop - bBottom;
    const lines = [];
    if (bTop) {
      lines.push(cTopleft + title + cTop.repeat(spaceWidth - titleWidth) + cTopright);
    }
    lines.push(...Array.from({ length: spaceHeight }, () => cLeft + " ".repeat(spaceWidth) + cRight));
    if (bBottom) {
      lines.push(cBotleft + cBottom.repeat(spaceWidth) + cBotright);
    }
    const highlights = [];
    const borderWinHl = (_f = options.borderWinHl) !== null && _f !== void 0 ? _f : defaultBorderWinHl;
    if (borderWinHl) {
      highlights.push({
        hlGroup: borderWinHl,
        line: 0,
        colStart: 0,
        colEnd: width
      });
      for (let l = 0, len = spaceHeight; l < len; l++) {
        if (bLeft) {
          highlights.push({
            hlGroup: borderWinHl,
            line: l + 1,
            colStart: 0,
            colEnd: bLeft
          });
        }
        if (bRight) {
          highlights.push({
            hlGroup: borderWinHl,
            line: l + 1,
            colStart: bLeft + spaceWidth,
            colEnd: width
          });
        }
      }
      if (bBottom) {
        highlights.push({
          hlGroup: borderWinHl,
          line: height - 1,
          colStart: 0,
          colEnd: width
        });
      }
    }
    return {
      lines,
      highlights
    };
  }
  renderBorderNotifier(buf, ctx, options, winOptions) {
    const renderData = this.getRenderBorderData(ctx, options, "width" in winOptions ? [winOptions.width, winOptions.height] : [winOptions.minwidth, winOptions.minheight]);
    if (!renderData) {
      return Notifier.noop();
    }
    const { lines, highlights } = renderData;
    return Notifier.create(() => {
      buf.setOption("modifiable", true, true);
      buf.setOption("readonly", false, true);
      void buf.setLines(lines, { start: 0, end: -1 }, true);
      buf.setOption("modifiable", false, true);
      buf.setOption("readonly", true, true);
      this.addHighlightsNotify(buf, highlights);
    });
  }
  nvimWinHl(options) {
    var _a, _b;
    if (import_coc10.workspace.isVim) {
      return "";
    }
    const arr = [];
    arr.push(`Normal:${(_a = options.winHl) !== null && _a !== void 0 ? _a : defaultWinHl}`);
    arr.push(`NormalNC:${(_b = options.winHlNC) !== null && _b !== void 0 ? _b : defaultWinHlNC}`);
    return arr.join(",");
  }
  addHighlightsNotify(buf, highlights) {
    for (const hl of highlights) {
      if (!hl.hlGroup || hl.line === void 0 || hl.colStart === void 0 || hl.colEnd === void 0) {
        continue;
      }
      buf.highlightRanges(this.srcId, hl.hlGroup, [
        import_coc10.Range.create(hl.line, hl.colStart, hl.line, hl.colEnd)
      ]);
    }
  }
};

// node_modules/coc-helper/lib/esm/FloatingWindow.js
var FloatingWindow = class _FloatingWindow {
  static getInitedExecute(mode, options) {
    var _a, _b, _c, _d;
    let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, _FloatingWindow.initedContextVars.create)) !== null && _b !== void 0 ? _b : "";
    initedExecute = `${_FloatingWindow.modePresets[mode].createInitedExecute(_FloatingWindow.initedContextVars.create)}
${initedExecute}`;
    const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, _FloatingWindow.initedContextVars.create)) !== null && _d !== void 0 ? _d : _FloatingWindow.modePresets.show.createInitedExecute(_FloatingWindow.initedContextVars.create);
    return [initedExecute, borderInitedExecute];
  }
  static async create(options = {}) {
    var _a, _b, _c;
    const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : "default";
    const [initedExecute, borderInitedExecute] = this.getInitedExecute(mode, options);
    const [bufnr, borderBufnr] = await floatingModule.create.call((_b = options.name) !== null && _b !== void 0 ? _b : "", initedExecute, (_c = options.hasBorderBuf) !== null && _c !== void 0 ? _c : true, borderInitedExecute);
    const floatingUtil = new FloatingUtil(this.srcId);
    return new _FloatingWindow(bufnr, borderBufnr !== null && borderBufnr !== void 0 ? borderBufnr : void 0, options, mode, floatingUtil);
  }
  constructor(bufnr, borderBufnr, createOptions, mode, util2) {
    this.bufnr = bufnr;
    this.borderBufnr = borderBufnr;
    this.createOptions = createOptions;
    this.mode = mode;
    this.util = util2;
    this.nvim = import_coc11.workspace.nvim;
    this.disposables = [];
    this.nvim = import_coc11.workspace.nvim;
    this.buffer = this.nvim.createBuffer(bufnr);
    if (borderBufnr) {
      this.borderBuffer = import_coc11.workspace.nvim.createBuffer(borderBufnr);
      this.disposables.push(import_coc11.events.on("BufWinLeave", helperLogger.asyncCatch(async (curBufnr) => {
        if (this.borderBufnr && curBufnr === this.bufnr) {
          await utilModule.closeWinByBufnr.call([this.borderBufnr]);
        }
      })));
    }
  }
  getInitedExecute(options) {
    var _a, _b, _c, _d;
    let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, _FloatingWindow.initedContextVars.open)) !== null && _b !== void 0 ? _b : "";
    initedExecute = `${_FloatingWindow.modePresets[this.mode].openInitedExecute(_FloatingWindow.initedContextVars.open)}
${initedExecute}`;
    const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, _FloatingWindow.initedContextVars.open)) !== null && _d !== void 0 ? _d : _FloatingWindow.modePresets.show.openInitedExecute(_FloatingWindow.initedContextVars.open);
    return [initedExecute, borderInitedExecute];
  }
  getFocus(options) {
    var _a, _b;
    return (_b = (_a = options.focus) !== null && _a !== void 0 ? _a : this.mode ? _FloatingWindow.modePresets[this.mode].focus : void 0) !== null && _b !== void 0 ? _b : false;
  }
  getModifiable(options) {
    var _a, _b;
    return (_b = (_a = options.modifiable) !== null && _a !== void 0 ? _a : this.mode ? _FloatingWindow.modePresets[this.mode].modifiable : void 0) !== null && _b !== void 0 ? _b : false;
  }
  setLinesNotifier(options) {
    return Notifier.create(() => {
      if (!options.lines && !options.modifiable) {
        return;
      }
      const modifiable = this.getModifiable(options);
      this.buffer.setOption("modifiable", true, true);
      this.buffer.setOption("readonly", false, true);
      if (options.lines) {
        void this.buffer.setLines(options.lines, { start: 0, end: -1 }, true);
      }
      if (!modifiable) {
        this.buffer.setOption("modifiable", false, true);
        this.buffer.setOption("readonly", true, true);
      }
      if (options.highlights) {
        for (const hl of options.highlights) {
          this.util.addHighlightsNotify(this.buffer, [hl]);
        }
      }
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    });
  }
  async setLines(options) {
    await this.setLinesNotifier(options).run();
  }
  async opened() {
    const win = await this.win();
    return !!win;
  }
  async openNotifier(options) {
    var _a;
    if (options.width <= 0 || options.height <= 0) {
      return Notifier.noop();
    }
    const notifiers = [];
    notifiers.push(this.closeNotifier());
    const ctx = await this.util.createContext(options);
    const [initedExecute, borderInitedExecute] = this.getInitedExecute(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
    if (options.borderOnly && borderWinConfig) {
      notifiers.push(floatingModule.open.callNotifier(this.bufnr, borderWinConfig, borderInitedExecute, null, null, "", false, this.util.nvimWinHl(options)));
      notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
    } else {
      notifiers.push(floatingModule.open.callNotifier(this.bufnr, winConfig, initedExecute, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, borderInitedExecute, this.getFocus(options), this.util.nvimWinHl(options)));
    }
    if (import_coc11.workspace.isNvim && this.borderBuffer && borderWinConfig) {
      notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
    }
    notifiers.push(this.setLinesNotifier(options), Notifier.create(() => {
      if (options.filetype) {
        this.buffer.setOption("filetype", options.filetype, true);
      }
    }));
    return Notifier.combine(notifiers);
  }
  async open(options) {
    await (await this.openNotifier(options)).run();
  }
  async resumeNotifier(options) {
    const ctx = await this.util.createContext(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
    return Notifier.create(() => {
      var _a;
      floatingModule.resume.callNotify(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.getFocus(options), this.util.nvimWinHl(options));
      if (this.borderBuffer && borderWinConfig) {
        this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig).notify();
      }
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    });
  }
  async resume(options) {
    await (await this.resumeNotifier(options)).run();
  }
  async resizeNotifier(options) {
    var _a;
    const ctx = await this.util.createContext(options);
    const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options, false);
    const notifiers = [];
    if (options.borderOnly && borderWinConfig) {
      notifiers.push(floatingModule.update.callNotifier(this.bufnr, borderWinConfig, null, null, this.util.nvimWinHl(options)));
      notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
    } else {
      notifiers.push(floatingModule.update.callNotifier(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.util.nvimWinHl(options)));
    }
    if (import_coc11.workspace.isNvim && this.borderBuffer && borderWinConfig) {
      notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
    }
    notifiers.push(Notifier.create(() => {
      if (import_coc11.workspace.isVim) {
        this.nvim.command("redraw!", true);
      }
    }));
    return Notifier.combine(notifiers);
  }
  async resize(options) {
    await (await this.resizeNotifier(options)).run();
  }
  async win() {
    const winid = await floatingModule.winid.call(this.bufnr);
    return winid ? this.nvim.createWindow(winid) : void 0;
  }
  async borderWin() {
    const borderWinid = await floatingModule.winid.call(this.bufnr);
    return borderWinid ? this.nvim.createWindow(borderWinid) : void 0;
  }
  closeNotifier() {
    return floatingModule.close.callNotifier(this.bufnr);
  }
  async close() {
    await this.closeNotifier().run();
  }
  dispose() {
    (0, import_coc11.disposeAll)(this.disposables);
    this.disposables.forEach((s) => s.dispose());
  }
};
FloatingWindow.modePresets = {
  default: {
    modifiable: false,
    focus: false,
    createInitedExecute: () => "",
    openInitedExecute: () => ""
  },
  base: {
    createInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&buftype', 'nofile')
        call setbufvar(${ctx.bufnr}, '&bufhidden', 'hide')
        call setbufvar(${ctx.bufnr}, '&buflisted', 0)

        call setbufvar(${ctx.bufnr}, '&wrap', 1)

        call setbufvar(${ctx.bufnr}, '&swapfile', 0)

        call setbufvar(${ctx.bufnr}, '&modeline', 0)
      `,
    openInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&list', 0)

        call setbufvar(${ctx.bufnr}, '&listchars', '')
        if has('nvim')
          call setbufvar(${ctx.bufnr}, '&fillchars', 'eob: ')
        endif

        call setbufvar(${ctx.bufnr}, '&signcolumn', 'no')
        call setbufvar(${ctx.bufnr}, '&number', 0)
        call setbufvar(${ctx.bufnr}, '&relativenumber', 0)
        call setbufvar(${ctx.bufnr}, '&foldenable', 0)
        call setbufvar(${ctx.bufnr}, '&foldcolumn', 0)

        call setbufvar(${ctx.bufnr}, '&spell', 0)

        call setbufvar(${ctx.bufnr}, '&cursorcolumn', 0)
        call setbufvar(${ctx.bufnr}, '&cursorline', 0)
        call setbufvar(${ctx.bufnr}, '&colorcolumn', '')
      `
  },
  show: {
    modifiable: false,
    createInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.createInitedExecute(ctx)}
        " call setbufvar(${ctx.bufnr}, '&undofile', 0)
        " call setbufvar(${ctx.bufnr}, '&undolevels', -1)

        call setbufvar(${ctx.bufnr}, '&modifiable', 0)
        call setbufvar(${ctx.bufnr}, '&modified', 0)
        call setbufvar(${ctx.bufnr}, '&readonly', 1)
      `,
    openInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.openInitedExecute(ctx)}
      `
  }
};
FloatingWindow.initedContextVars = {
  create: { bufnr: "a:ctx.bufnr" },
  open: { bufnr: "a:ctx.bufnr", winid: "a:ctx.winid" }
};
FloatingWindow.srcId = "coc-helper-floatwin";

// node_modules/coc-helper/lib/esm/MultiFloatingWindow.js
var import_coc12 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/events.js
var import_coc13 = require("coc.nvim");

// node_modules/coc-helper/lib/esm/WinLayoutFinder.js
var import_coc14 = require("coc.nvim");

// src/util.ts
var import_coc16 = require("coc.nvim");
var logger = new HelperLogger("markdown-preview-enhanced");
var webviewExt;
var getWebviewAPI = () => {
  if (!webviewExt) {
    webviewExt = import_coc16.extensions.all.find((ext) => ext.id === "coc-webview");
  }
  if (!webviewExt) {
    const prompt = "Please install the coc-webview extension";
    void import_coc16.window.showErrorMessage(prompt);
    throw new Error(prompt);
  }
  return webviewExt.exports;
};

// src/image-helper.ts
async function pasteImageFile(sourceUri, imageFilePath) {
  const finalSourceUri = typeof sourceUri === "string" ? import_coc17.Uri.parse(sourceUri) : sourceUri;
  const imageFolderPath = import_coc17.workspace.getConfiguration("markdown-preview-enhanced").get("imageFolderPath");
  let imageFileName = path.basename(imageFilePath);
  const projectDirectoryPath = import_coc17.workspace.root;
  let assetDirectoryPath;
  let description;
  if (imageFolderPath[0] === "/") {
    assetDirectoryPath = path.resolve(
      projectDirectoryPath,
      `.${imageFolderPath}`
    );
  } else {
    assetDirectoryPath = path.resolve(
      path.dirname(finalSourceUri.fsPath),
      imageFolderPath
    );
  }
  const destPath = path.resolve(
    assetDirectoryPath,
    path.basename(imageFilePath)
  );
  const doc = await import_coc17.workspace.document;
  const pos = await import_coc17.window.getCursorPosition();
  fs.mkdir(assetDirectoryPath, () => {
    fs.stat(destPath, (err) => {
      if (err == null) {
        const lastDotOffset = imageFileName.lastIndexOf(".");
        const uid = `_${Math.random().toString(36).substring(2, 10)}`;
        if (lastDotOffset > 0) {
          description = imageFileName.slice(0, lastDotOffset);
          imageFileName = imageFileName.slice(0, lastDotOffset) + uid + imageFileName.slice(lastDotOffset, imageFileName.length);
        } else {
          description = imageFileName;
          imageFileName = imageFileName + uid;
        }
        fs.createReadStream(imageFilePath).pipe(
          fs.createWriteStream(path.resolve(assetDirectoryPath, imageFileName))
        );
      } else if (err.code === "ENOENT") {
        fs.createReadStream(imageFilePath).pipe(fs.createWriteStream(destPath));
        if (imageFileName.lastIndexOf(".")) {
          description = imageFileName.slice(0, imageFileName.lastIndexOf("."));
        } else {
          description = imageFileName;
        }
      } else {
        import_coc17.window.showErrorMessage(err.message.toString()).catch(logger.error);
      }
      void import_coc17.window.showInformationMessage(
        `Image ${imageFileName} has been copied to folder ${assetDirectoryPath}`
      );
      let url = `${imageFolderPath}/${imageFileName}`;
      if (url.indexOf(" ") >= 0) {
        url = url.replace(/ /g, "%20");
      }
      doc.applyEdits([import_coc17.TextEdit.insert(pos, `![${description}](${url})`)]).catch(logger.error);
    });
  });
}
function replaceHint(doc, line, hint, withStr) {
  const textLine = doc.getline(line);
  if (textLine.indexOf(hint) >= 0) {
    doc.applyEdits([
      import_coc17.TextEdit.replace(
        import_coc17.Range.create(
          import_coc17.Position.create(line, 0),
          import_coc17.Position.create(line, textLine.length)
        ),
        textLine.replace(hint, withStr)
      )
    ]).catch(logger.error);
    return true;
  }
  return false;
}
function setUploadedImageURL(imageFileName, url, doc, hint, curPos) {
  let description;
  if (imageFileName.lastIndexOf(".")) {
    description = imageFileName.slice(0, imageFileName.lastIndexOf("."));
  } else {
    description = imageFileName;
  }
  const withStr = `![${description}](${url})`;
  if (!replaceHint(doc, curPos.line, hint, withStr)) {
    let i = curPos.line - 20;
    while (i <= curPos.line + 20) {
      if (replaceHint(doc, i, hint, withStr)) {
        break;
      }
      i++;
    }
  }
}
async function uploadImageFile(sourceUri, imageFilePath, imageUploader) {
  if (typeof sourceUri === "string") {
    sourceUri = import_coc17.Uri.parse(sourceUri);
  }
  const imageFileName = path.basename(imageFilePath);
  const doc = await import_coc17.workspace.document;
  const uid = Math.random().toString(36).substring(2, 10);
  const hint = `![Uploading ${imageFileName}\u2026 (${uid})]()`;
  const curPos = await import_coc17.window.getCursorPosition();
  await doc.applyEdits([import_coc17.TextEdit.insert(curPos, hint)]);
  const config = import_coc17.workspace.getConfiguration("markdown-preview-enhanced");
  const AccessKey = config.get("AccessKey") || "";
  const SecretKey = config.get("SecretKey") || "";
  const Bucket = config.get("Bucket") || "";
  const Domain = config.get("Domain") || "";
  import_mume.utility.uploadImage(imageFilePath, {
    method: imageUploader,
    qiniu: { AccessKey, SecretKey, Bucket, Domain }
  }).then((url) => {
    setUploadedImageURL(imageFileName, url, doc, hint, curPos);
  }).catch(logger.error);
}

// src/preview-content-provider.ts
var mume = __toESM(require("@shd101wyy/mume"));
var import_mume2 = require("@shd101wyy/mume");
var import_coc19 = require("coc.nvim");
var import_path = __toESM(require("path"));

// src/config.ts
var import_coc18 = require("coc.nvim");
var MarkdownPreviewEnhancedConfig = class _MarkdownPreviewEnhancedConfig {
  static getCurrentConfig() {
    return new _MarkdownPreviewEnhancedConfig();
  }
  constructor() {
    const config = import_coc18.workspace.getConfiguration("markdown-preview-enhanced");
    this.configPath = (config.get("configPath") || "").trim();
    this.usePandocParser = config.get("usePandocParser");
    this.breakOnSingleNewLine = config.get("breakOnSingleNewLine");
    this.enableTypographer = config.get("enableTypographer");
    this.enableWikiLinkSyntax = config.get("enableWikiLinkSyntax");
    this.enableLinkify = config.get("enableLinkify");
    this.useGitHubStylePipedLink = config.get(
      "useGitHubStylePipedLink"
    );
    this.wikiLinkFileExtension = config.get("wikiLinkFileExtension");
    this.enableEmojiSyntax = config.get("enableEmojiSyntax");
    this.enableExtendedTableSyntax = config.get(
      "enableExtendedTableSyntax"
    );
    this.enableCriticMarkupSyntax = config.get(
      "enableCriticMarkupSyntax"
    );
    this.frontMatterRenderingOption = config.get(
      "frontMatterRenderingOption"
    );
    this.mermaidTheme = config.get("mermaidTheme");
    this.mathRenderingOption = config.get(
      "mathRenderingOption"
    );
    this.mathInlineDelimiters = config.get("mathInlineDelimiters");
    this.mathBlockDelimiters = config.get("mathBlockDelimiters");
    this.mathRenderingOnlineService = config.get(
      "mathRenderingOnlineService"
    );
    this.mathjaxV3ScriptSrc = config.get("mathjaxV3ScriptSrc");
    this.codeBlockTheme = config.get("codeBlockTheme");
    this.previewTheme = config.get("previewTheme");
    this.revealjsTheme = config.get("revealjsTheme");
    this.protocolsWhiteList = config.get("protocolsWhiteList");
    this.imageFolderPath = config.get("imageFolderPath");
    this.imageUploader = config.get("imageUploader");
    this.printBackground = config.get("printBackground");
    this.chromePath = config.get("chromePath");
    this.imageMagickPath = config.get("imageMagickPath");
    this.pandocPath = config.get("pandocPath");
    this.pandocMarkdownFlavor = config.get("pandocMarkdownFlavor");
    this.pandocArguments = config.get("pandocArguments");
    this.latexEngine = config.get("latexEngine");
    this.enableScriptExecution = config.get("enableScriptExecution");
    this.scrollSync = config.get("scrollSync");
    this.liveUpdate = config.get("liveUpdate");
    this.singlePreview = config.get("singlePreview");
    this.automaticallyShowPreviewOfMarkdownBeingEdited = config.get(
      "automaticallyShowPreviewOfMarkdownBeingEdited"
    );
    this.previewColorScheme = config.get("previewColorScheme");
    this.enableHTML5Embed = config.get("enableHTML5Embed");
    this.HTML5EmbedUseImageSyntax = config.get(
      "HTML5EmbedUseImageSyntax"
    );
    this.HTML5EmbedUseLinkSyntax = config.get(
      "HTML5EmbedUseLinkSyntax"
    );
    this.HTML5EmbedIsAllowedHttp = config.get(
      "HTML5EmbedIsAllowedHttp"
    );
    this.HTML5EmbedAudioAttributes = config.get(
      "HTML5EmbedAudioAttributes"
    );
    this.HTML5EmbedVideoAttributes = config.get(
      "HTML5EmbedVideoAttributes"
    );
    this.puppeteerWaitForTimeout = config.get(
      "puppeteerWaitForTimeout"
    );
    this.usePuppeteerCore = config.get("usePuppeteerCore");
    this.puppeteerArgs = config.get("puppeteerArgs");
    this.plantumlJarPath = config.get("plantumlJarPath");
    this.plantumlServer = config.get("plantumlServer");
    this.jsdelivrCdnHost = config.get("jsdelivrCdnHost");
    this.krokiServer = config.get("krokiServer");
  }
  isEqualTo(otherConfig) {
    const json1 = JSON.stringify(this);
    const json2 = JSON.stringify(otherConfig);
    return json1 === json2;
  }
};

// src/preview-content-provider.ts
var MarkdownPreviewEnhancedView = class {
  constructor(context) {
    this.context = context;
    this.waiting = false;
    /**
     * The key is markdown file fsPath
     * value is MarkdownEngine
     */
    this.engineMaps = {};
    /**
     * The key is markdown file fspath
     * value is Preview (Webview) object
     */
    this.previewMaps = {};
    this.preview2EditorMap = /* @__PURE__ */ new Map();
    this.singlePreviewPanel = null;
    this.singlePreviewPanelSourceUriTarget = null;
    /**
     * The key is markdown file fsPath
     * value is JSAndCssFiles
     */
    this.jsAndCssFilesMaps = {};
    this.systemColorScheme = "light";
    this.config = MarkdownPreviewEnhancedConfig.getCurrentConfig();
    mume.init(this.config.configPath).then(async () => {
      mume.onDidChangeConfigFile(this.refreshAllPreviews.bind(this));
      import_mume2.MarkdownEngine.onModifySource(this.modifySource.bind(this));
      mume.utility.useExternalAddFileProtocolFunction(
        (filePath, preview) => {
          if (preview) {
            return preview.webview.asWebviewUri(import_coc19.Uri.file(filePath)).toString(true).replace(/%3F/gi, "?").replace(/%23/g, "#");
          } else {
            if (!filePath.startsWith("file://")) {
              filePath = `file:///${filePath}`;
            }
            filePath = filePath.replace(/^file:\/+/, "file:///");
            return filePath;
          }
        }
      );
    }).catch((error) => {
      void import_coc19.window.showErrorMessage(error.toString());
    });
  }
  refreshAllPreviews() {
    for (const key in this.engineMaps) {
      if (Object.prototype.hasOwnProperty.call(this.engineMaps, key)) {
        const engine = this.engineMaps[key];
        if (engine) {
          engine.clearCaches();
        }
      }
    }
    if (useSinglePreview()) {
      if (!this.singlePreviewPanelSourceUriTarget) {
        return;
      }
      this.refreshPreviewPanel(this.singlePreviewPanelSourceUriTarget);
    } else {
      for (const key in this.previewMaps) {
        if (Object.prototype.hasOwnProperty.call(this.previewMaps, key)) {
          this.refreshPreviewPanel(import_coc19.Uri.file(key));
        }
      }
    }
  }
  /**
   * modify markdown source, append `result` after corresponding code chunk.
   * @param codeChunkData
   * @param result
   * @param filePath
   */
  async modifySource(codeChunkData, result, filePath) {
    async function insertResult(i, doc2) {
      const lineCount = doc2.lineCount;
      let start = 0;
      for (let j = i + 1; j < i + 6 && j < lineCount; j++) {
        if (doc2.getline(j).startsWith("<!-- code_chunk_output -->")) {
          start = j;
          break;
        }
      }
      if (start) {
        let end = start + 1;
        while (end < lineCount) {
          if (doc2.getline(end).startsWith("<!-- /code_chunk_output -->")) {
            break;
          }
          end += 1;
        }
        let r = "";
        for (let i2 = start + 2; i2 < end - 1; i2++) {
          r += `${doc2.getline(i2)}
`;
        }
        if (r === `${result}
`) {
          return "";
        }
        await doc2.applyEdits([
          import_coc19.TextEdit.replace(
            import_coc19.Range.create(
              import_coc19.Position.create(start + 2, 0),
              import_coc19.Position.create(end - 1, 0)
            ),
            `${result}
`
          )
        ]);
        return "";
      } else {
        await doc2.applyEdits([
          import_coc19.TextEdit.insert(
            import_coc19.Position.create(i + 1, 0),
            `
<!-- code_chunk_output -->

${result}

<!-- /code_chunk_output -->
`
          )
        ]);
        return "";
      }
    }
    const doc = await import_coc19.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return "";
    }
    if (this.formatPathIfNecessary(import_coc19.Uri.parse(doc.uri).fsPath) === filePath) {
      let codeChunkOffset = 0;
      const targetCodeChunkOffset = codeChunkData.normalizedInfo.attributes["code_chunk_offset"];
      const lineCount = doc.lineCount;
      for (let i2 = 0; i2 < lineCount; i2++) {
        const line = doc.getline(i2);
        if (line.match(/^```(.+)"?cmd"?\s*[=\s}]/)) {
          if (codeChunkOffset === targetCodeChunkOffset) {
            i2 = i2 + 1;
            while (i2 < lineCount) {
              if (doc.getline(i2).match(/^```\s*/)) {
                break;
              }
              i2 += 1;
            }
            return insertResult(i2, doc);
          } else {
            codeChunkOffset++;
          }
        } else if (line.match(/@import\s+(.+)"?cmd"?\s*[=\s}]/)) {
          if (codeChunkOffset === targetCodeChunkOffset) {
            return insertResult(i2, doc);
          } else {
            codeChunkOffset++;
          }
        }
      }
    }
    return "";
  }
  /**
   * return markdown engine of sourceUri
   * @param sourceUri
   */
  getEngine(sourceUri) {
    return this.engineMaps[sourceUri.fsPath];
  }
  /**
   * return markdown preview of sourceUri
   * @param sourceUri
   */
  getPreview(sourceUri) {
    if (useSinglePreview()) {
      return this.singlePreviewPanel;
    } else {
      return this.previewMaps[sourceUri.fsPath];
    }
  }
  /**
   * check if the markdown preview is on for the textEditor
   * @param textEditor
   */
  isPreviewOn(sourceUri) {
    if (useSinglePreview()) {
      return !!this.singlePreviewPanel;
    } else {
      return !!this.getPreview(sourceUri);
    }
  }
  destroyPreview(sourceUri) {
    if (useSinglePreview()) {
      this.singlePreviewPanel = null;
      this.singlePreviewPanelSourceUriTarget = null;
      this.preview2EditorMap = /* @__PURE__ */ new Map();
      this.previewMaps = {};
    } else {
      const previewPanel = this.getPreview(sourceUri);
      if (previewPanel) {
        this.preview2EditorMap.delete(previewPanel);
        delete this.previewMaps[sourceUri.fsPath];
      }
    }
  }
  /**
   * remove engine from this.engineMaps
   * @param sourceUri
   */
  destroyEngine(sourceUri) {
    if (useSinglePreview()) {
      return this.engineMaps = {};
    }
    const engine = this.getEngine(sourceUri);
    if (engine) {
      delete this.engineMaps[sourceUri.fsPath];
    }
  }
  /**
   * Format pathString if it is on Windows. Convert `c:\` like string to `C:\`
   * @param pathString
   */
  formatPathIfNecessary(pathString) {
    if (process.platform === "win32") {
      pathString = pathString.replace(
        /^([a-zA-Z]):\\/,
        (_, $1) => `${$1.toUpperCase()}:\\`
      );
    }
    return pathString;
  }
  getProjectDirectoryPath(sourceUri, workspaceFolders = []) {
    const possibleWorkspaceFolders = workspaceFolders.map((workspaceFolder) => import_coc19.Uri.parse(workspaceFolder.uri).fsPath).filter((workspaceFolder) => {
      return import_path.default.dirname(sourceUri.path.toUpperCase()).indexOf(workspaceFolder.toUpperCase()) >= 0;
    });
    let projectDirectoryPath;
    if (possibleWorkspaceFolders.length) {
      const workspaceFolder = possibleWorkspaceFolders.sort(
        (x, y) => y.length - x.length
      )[0];
      projectDirectoryPath = workspaceFolder;
    } else {
      projectDirectoryPath = "";
    }
    return this.formatPathIfNecessary(projectDirectoryPath);
  }
  getFilePath(sourceUri) {
    return this.formatPathIfNecessary(sourceUri.fsPath);
  }
  /**
   * Initialize MarkdownEngine for this markdown file
   */
  async initMarkdownEngine(sourceUri) {
    let engine = this.getEngine(sourceUri);
    if (!engine) {
      const previewTheme = await this.getPreviewTheme(
        this.config.previewTheme,
        this.config.previewColorScheme
      );
      engine = new import_mume2.MarkdownEngine({
        filePath: this.getFilePath(sourceUri),
        projectDirectoryPath: this.getProjectDirectoryPath(
          sourceUri,
          import_coc19.workspace.workspaceFolders
        ),
        config: { ...this.config, previewTheme }
      });
      this.engineMaps[sourceUri.fsPath] = engine;
      this.jsAndCssFilesMaps[sourceUri.fsPath] = [];
    }
    return engine;
  }
  getWebviewOptions(localResourceRoots) {
    return {
      enableScripts: true,
      // TODO: This might be set by enableScriptExecution config. But for now we just enable it.
      localResourceRoots
    };
  }
  async initPreview(sourceUri, doc, openURL) {
    const isUsingSinglePreview = useSinglePreview();
    let previewPanel;
    if (isUsingSinglePreview && this.singlePreviewPanel) {
      if (!this.singlePreviewPanelSourceUriTarget) {
        return;
      }
      const oldResourceRoot = this.getProjectDirectoryPath(
        this.singlePreviewPanelSourceUriTarget,
        import_coc19.workspace.workspaceFolders
      ) || import_path.default.dirname(this.singlePreviewPanelSourceUriTarget.fsPath);
      const newResourceRoot = this.getProjectDirectoryPath(sourceUri, import_coc19.workspace.workspaceFolders) || import_path.default.dirname(sourceUri.fsPath);
      logger.info(sourceUri.path);
      logger.info(import_coc19.workspace.workspaceFolders[0].uri);
      logger.info(oldResourceRoot);
      logger.info(newResourceRoot);
      if (oldResourceRoot !== newResourceRoot) {
        this.singlePreviewPanel.dispose();
        return this.initPreview(sourceUri, doc, openURL);
      } else {
        previewPanel = this.singlePreviewPanel;
        this.singlePreviewPanelSourceUriTarget = sourceUri;
        if (openURL) {
          previewPanel.reveal({
            openURL
          });
        }
      }
    } else if (this.previewMaps[sourceUri.fsPath]) {
      previewPanel = this.previewMaps[sourceUri.fsPath];
      if (openURL) {
        previewPanel.reveal({
          openURL
        });
      }
    } else {
      const localResourceRoots = [
        import_coc19.Uri.file(this.context.extensionPath),
        import_coc19.Uri.file(mume.utility.getExtensionDirectoryPath()),
        import_coc19.Uri.file(mume.getExtensionConfigPath()),
        // Uri.file(tmpdir()),
        import_coc19.Uri.file(
          this.getProjectDirectoryPath(sourceUri, import_coc19.workspace.workspaceFolders) || import_path.default.dirname(sourceUri.fsPath)
        )
      ];
      previewPanel = await getWebviewAPI().createWebviewPanel(
        "markdown-preview-enhanced",
        `Preview ${import_path.default.basename(sourceUri.fsPath)}`,
        {
          openURL,
          routeName: "markdown-preview-enhanced"
        },
        this.getWebviewOptions(localResourceRoots)
      );
      previewPanel.iconPath = import_coc19.Uri.file(
        import_path.default.join(this.context.extensionPath, "media", "preview.svg")
      );
      previewPanel.webview.onDidReceiveMessage(
        (message) => {
          import_coc19.commands.executeCommand(`_mume.${message.command}`, ...message.args).catch(logger.error);
        },
        null,
        this.context.subscriptions
      );
      previewPanel.onDidDispose(
        () => {
          this.destroyPreview(sourceUri);
          this.destroyEngine(sourceUri);
        },
        null,
        this.context.subscriptions
      );
      if (isUsingSinglePreview) {
        this.singlePreviewPanel = previewPanel;
        this.singlePreviewPanelSourceUriTarget = sourceUri;
      }
    }
    this.previewMaps[sourceUri.fsPath] = previewPanel;
    this.preview2EditorMap.set(previewPanel, doc);
    previewPanel.title = `Preview ${import_path.default.basename(sourceUri.fsPath)}`;
    let initialLine;
    if (doc && doc.uri === sourceUri.fsPath) {
      const cursor = await (await import_coc19.workspace.nvim.window).cursor;
      initialLine = cursor[0] ? cursor[0] - 1 : 0;
    }
    const text = doc.getDocumentContent();
    let engine = this.getEngine(sourceUri);
    if (!engine) {
      engine = await this.initMarkdownEngine(sourceUri);
    }
    engine.generateHTMLTemplateForPreview({
      inputString: text,
      config: {
        sourceUri: sourceUri.toString(),
        initialLine: initialLine ?? null,
        vscode: true
      },
      contentSecurityPolicy: "",
      vscodePreviewPanel: previewPanel
    }).then((html) => {
      previewPanel.webview.html = html;
    }).catch(logger.error);
  }
  /**
   * Close all previews
   */
  closeAllPreviews(singlePreview) {
    if (singlePreview) {
      if (this.singlePreviewPanel) {
        this.singlePreviewPanel.dispose();
      }
    } else {
      const previewPanels = [];
      for (const key in this.previewMaps) {
        if (Object.prototype.hasOwnProperty.call(this.previewMaps, key)) {
          const previewPanel = this.previewMaps[key];
          if (previewPanel) {
            previewPanels.push(previewPanel);
          }
        }
      }
      previewPanels.forEach((previewPanel) => previewPanel.dispose());
    }
    this.previewMaps = {};
    this.preview2EditorMap = /* @__PURE__ */ new Map();
    this.engineMaps = {};
    this.singlePreviewPanel = null;
    this.singlePreviewPanelSourceUriTarget = null;
  }
  previewPostMessage(sourceUri, message) {
    const preview = this.getPreview(sourceUri);
    if (preview) {
      void preview.webview.postMessage(message);
    }
  }
  previewHasTheSameSingleSourceUri(sourceUri) {
    if (!this.singlePreviewPanelSourceUriTarget) {
      return false;
    } else {
      return this.singlePreviewPanelSourceUriTarget.fsPath === sourceUri.fsPath;
    }
  }
  updateMarkdown(sourceUri, triggeredBySave) {
    const engine = this.getEngine(sourceUri);
    if (!engine) {
      return;
    }
    const previewPanel = this.getPreview(sourceUri);
    if (!previewPanel) {
      return;
    }
    if (engine.isPreviewInPresentationMode) {
      return this.refreshPreview(sourceUri);
    }
    const doc = import_coc19.workspace.getDocument(sourceUri.path);
    const text = doc.getDocumentContent();
    this.previewPostMessage(sourceUri, {
      command: "startParsingMarkdown"
    });
    const preview = this.getPreview(sourceUri);
    engine.parseMD(text, {
      isForPreview: true,
      useRelativeFilePath: false,
      hideFrontMatter: false,
      triggeredBySave,
      vscodePreviewPanel: preview
    }).then(async ({ html, tocHTML, JSAndCssFiles, yamlConfig }) => {
      if (JSON.stringify(JSAndCssFiles) !== JSON.stringify(this.jsAndCssFilesMaps[sourceUri.fsPath]) || yamlConfig["isPresentationMode"]) {
        this.jsAndCssFilesMaps[sourceUri.fsPath] = JSAndCssFiles;
        this.refreshPreview(sourceUri);
      } else {
        this.previewPostMessage(sourceUri, {
          command: "updateHTML",
          html,
          tocHTML,
          totalLineCount: doc.lineCount,
          sourceUri: sourceUri.toString(),
          id: yamlConfig.id || "",
          class: `${yamlConfig.class || ""} ${this.systemColorScheme === "dark" ? "system-dark" : "system-ligtht"} ${await this.getEditorColorScheme() === "dark" ? "editor-dark" : "editor-light"}`
        });
      }
    }).catch(logger.error);
  }
  refreshPreviewPanel(sourceUri) {
    this.preview2EditorMap.forEach((doc, previewPanel) => {
      if (previewPanel && doc && isMarkdownFile(doc.textDocument) && doc.uri && doc.uri === sourceUri.fsPath) {
        void this.initPreview(sourceUri, doc, false);
      }
    });
  }
  refreshPreview(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.clearCaches();
      this.refreshPreviewPanel(sourceUri);
    }
  }
  openInBrowser(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.openInBrowser({}).catch((error) => {
        import_coc19.window.showErrorMessage(error.toString()).catch(logger.error);
      });
    }
  }
  htmlExport(sourceUri, offline) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.htmlExport({ offline }).then((dest) => {
        void import_coc19.window.showInformationMessage(
          `File ${import_path.default.basename(dest)} was created at path: ${dest}`
        );
      }).catch((error) => {
        void import_coc19.window.showErrorMessage(error.toString());
      });
    }
  }
  chromeExport(sourceUri, type) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.chromeExport({ fileType: type, openFileAfterGeneration: true }).then((dest) => {
        void import_coc19.window.showInformationMessage(
          `File ${import_path.default.basename(dest)} was created at path: ${dest}`
        );
      }).catch((error) => {
        void import_coc19.window.showErrorMessage(error.toString());
      });
    }
  }
  princeExport(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.princeExport({ openFileAfterGeneration: true }).then((dest) => {
        if (dest.endsWith("?print-pdf")) {
          void import_coc19.window.showInformationMessage(
            `Please copy and open the link: { ${dest.replace(
              /_/g,
              "\\_"
            )} } in Chrome then Print as Pdf.`
          );
        } else {
          void import_coc19.window.showInformationMessage(
            `File ${import_path.default.basename(dest)} was created at path: ${dest}`
          );
        }
      }).catch((error) => {
        void import_coc19.window.showErrorMessage(error.toString());
      });
    }
  }
  eBookExport(sourceUri, fileType) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.eBookExport({ fileType, runAllCodeChunks: false }).then((dest) => {
        void import_coc19.window.showInformationMessage(
          `eBook ${import_path.default.basename(dest)} was created as path: ${dest}`
        );
      }).catch((error) => {
        void import_coc19.window.showErrorMessage(error.toString());
      });
    }
  }
  pandocExport(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.pandocExport({ openFileAfterGeneration: true }).then((dest) => {
        void import_coc19.window.showInformationMessage(
          `Document ${import_path.default.basename(dest)} was created as path: ${dest}`
        );
      }).catch((error) => {
        void import_coc19.window.showErrorMessage(error.toString());
      });
    }
  }
  markdownExport(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.markdownExport({}).then((dest) => {
        void import_coc19.window.showInformationMessage(
          `Document ${import_path.default.basename(dest)} was created as path: ${dest}`
        );
      }).catch((error) => {
        void import_coc19.window.showErrorMessage(error.toString());
      });
    }
  }
  /*
  public cacheSVG(sourceUri: Uri, code:string, svg:string) {
    const engine = this.getEngine(sourceUri)
    if (engine) {
      engine.cacheSVG(code, svg)
    }
  }
  */
  cacheCodeChunkResult(sourceUri, id, result) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.cacheCodeChunkResult(id, result);
    }
  }
  runCodeChunk(sourceUri, codeChunkId) {
    const engine = this.getEngine(sourceUri);
    logger.prettyPrint(sourceUri.toString(), codeChunkId);
    if (engine) {
      engine.runCodeChunk(codeChunkId).then(() => {
        this.updateMarkdown(sourceUri);
      }).catch(logger.error);
    }
  }
  runAllCodeChunks(sourceUri) {
    const engine = this.getEngine(sourceUri);
    if (engine) {
      engine.runCodeChunks().then(() => {
        this.updateMarkdown(sourceUri);
      }).catch(logger.error);
    }
  }
  update(sourceUri) {
    if (!this.config.liveUpdate || !this.getPreview(sourceUri)) {
      return;
    }
    if (!this.waiting) {
      this.waiting = true;
      setTimeout(() => {
        this.waiting = false;
        this.updateMarkdown(sourceUri);
      }, 300);
    }
  }
  async getEditorColorScheme() {
    if (await import_coc19.workspace.nvim.getOption("background") === "light") {
      return "light";
    } else {
      return "dark";
    }
  }
  async setSystemColorScheme(colorScheme) {
    if (this.systemColorScheme !== colorScheme) {
      this.systemColorScheme = colorScheme;
      if (this.config.previewColorScheme === "systemColorScheme" /* systemColorScheme */) {
        await this.updateConfiguration(true);
      }
    }
  }
  async updateConfiguration(forceUpdate = false) {
    const newConfig = MarkdownPreviewEnhancedConfig.getCurrentConfig();
    if (forceUpdate || !this.config.isEqualTo(newConfig)) {
      if (this.config.singlePreview !== newConfig.singlePreview) {
        this.closeAllPreviews(this.config.singlePreview);
        this.config = newConfig;
      } else {
        this.config = newConfig;
        for (const fsPath in this.engineMaps) {
          if (Object.prototype.hasOwnProperty.call(this.engineMaps, fsPath)) {
            const engine = this.engineMaps[fsPath];
            const previewTheme = await this.getPreviewTheme(
              newConfig.previewTheme,
              newConfig.previewColorScheme
            );
            engine.updateConfiguration({ ...newConfig, previewTheme });
          }
        }
        this.refreshAllPreviews();
      }
    }
  }
  getPreviewThemeByLightOrDark(theme, color) {
    switch (theme) {
      case "atom-dark.css":
      case "atom-light.css": {
        return color === "light" ? "atom-light.css" : "atom-dark.css";
      }
      case "github-dark.css":
      case "github-light.css": {
        return color === "light" ? "github-light.css" : "github-dark.css";
      }
      case "one-light.css":
      case "one-dark.css": {
        return color === "light" ? "one-light.css" : "one-dark.css";
      }
      case "solarized-light.css":
      case "solarized-dark.css": {
        return color === "light" ? "solarized-light.css" : "solarized-dark.css";
      }
      default: {
        return theme;
      }
    }
  }
  async getPreviewTheme(theme, colorScheme) {
    if (colorScheme === "editorColorScheme" /* editorColorScheme */) {
      return this.getPreviewThemeByLightOrDark(
        theme,
        await this.getEditorColorScheme()
      );
    } else if (colorScheme === "systemColorScheme" /* systemColorScheme */) {
      return this.getPreviewThemeByLightOrDark(theme, this.systemColorScheme);
    } else {
      return theme;
    }
  }
  openImageHelper(sourceUri) {
    if (sourceUri.scheme === "markdown-preview-enhanced") {
      return import_coc19.window.showWarningMessage("Please focus a markdown file.");
    } else if (!this.isPreviewOn(sourceUri)) {
      return import_coc19.window.showWarningMessage("Please open preview first.");
    } else {
      return this.previewPostMessage(sourceUri, {
        command: "openImageHelper"
      });
    }
  }
};
function useSinglePreview() {
  const config = import_coc19.workspace.getConfiguration("markdown-preview-enhanced");
  return config.get("singlePreview");
}
function getPreviewUri(uri) {
  if (uri.scheme === "markdown-preview-enhanced") {
    return uri;
  }
  let previewUri;
  if (useSinglePreview()) {
    previewUri = uri.with({
      scheme: "markdown-preview-enhanced",
      path: "single-preview.rendered"
    });
  } else {
    previewUri = uri.with({
      scheme: "markdown-preview-enhanced",
      path: `${uri.path}.rendered`,
      query: uri.toString()
    });
  }
  return previewUri;
}
function isMarkdownFile(document) {
  const uri = import_coc19.Uri.parse(document.uri);
  return document.languageId === "markdown" && uri.scheme !== "markdown-preview-enhanced";
}

// src/index.ts
var editorScrollDelay = Date.now();
async function openInVim(uri, type) {
  const nvim = import_coc20.workspace.nvim;
  const escapedPath = await import_coc20.workspace.nvim.call("fnameescape", [
    uri.fsPath
  ]);
  nvim.pauseNotification();
  if (type === "vsplit") {
    nvim.command(`vsplit ${escapedPath}`, true);
  } else {
    nvim.command(`edit ${escapedPath}`, true);
  }
  if (import_coc20.workspace.isVim) {
    nvim.command("redraw", true);
  }
  await nvim.resumeNotification(true);
}
function activate(context) {
  const contentProvider = new MarkdownPreviewEnhancedView(context);
  async function openPreview(openURL, uri) {
    const doc = await import_coc20.workspace.document;
    let resource = uri;
    if (!(resource instanceof import_coc20.Uri)) {
      resource = import_coc20.Uri.parse(doc.uri);
    }
    await contentProvider.initPreview(resource, doc, openURL);
  }
  async function toggleScrollSync() {
    const config = import_coc20.workspace.getConfiguration("markdown-preview-enhanced");
    const scrollSync = !config.get("scrollSync");
    await config.update("scrollSync", scrollSync, true);
    await contentProvider.updateConfiguration();
    if (scrollSync) {
      void import_coc20.window.showInformationMessage("Scroll Sync is enabled");
    } else {
      void import_coc20.window.showInformationMessage("Scroll Sync is disabled");
    }
  }
  async function toggleLiveUpdate() {
    const config = import_coc20.workspace.getConfiguration("markdown-preview-enhanced");
    const liveUpdate = !config.get("liveUpdate");
    await config.update("liveUpdate", liveUpdate, true);
    await contentProvider.updateConfiguration();
    if (liveUpdate) {
      void import_coc20.window.showInformationMessage("Live Update is enabled");
    } else {
      void import_coc20.window.showInformationMessage("Live Update is disabled");
    }
  }
  async function toggleBreakOnSingleNewLine() {
    const config = import_coc20.workspace.getConfiguration("markdown-preview-enhanced");
    const breakOnSingleNewLine = !config.get("breakOnSingleNewLine");
    await config.update("breakOnSingleNewLine", breakOnSingleNewLine, true);
    await contentProvider.updateConfiguration();
    if (breakOnSingleNewLine) {
      void import_coc20.window.showInformationMessage("Break On Single New Line is enabled");
    } else {
      void import_coc20.window.showInformationMessage("Break On Single New Line is disabled");
    }
  }
  async function customizeCSS() {
    const globalStyleLessFile = import_mume3.utility.addFileProtocol(
      import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./style.less")
    );
    await openInVim(import_coc20.Uri.parse(globalStyleLessFile), "vsplit");
  }
  async function openMermaidConfig() {
    const mermaidConfigFilePath = import_mume3.utility.addFileProtocol(
      import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./mermaid_config.js")
    );
    await openInVim(import_coc20.Uri.parse(mermaidConfigFilePath), "vsplit");
  }
  async function openMathJaxConfig() {
    const mathjaxConfigFilePath = import_mume3.utility.addFileProtocol(
      import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./mathjax_config.js")
    );
    await openInVim(import_coc20.Uri.parse(mathjaxConfigFilePath), "vsplit");
  }
  async function openKaTeXConfig() {
    const katexConfigFilePath = import_mume3.utility.addFileProtocol(
      import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./katex_config.js")
    );
    await openInVim(import_coc20.Uri.parse(katexConfigFilePath), "vsplit");
  }
  async function extendParser() {
    const parserConfigPath = import_mume3.utility.addFileProtocol(
      import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./parser.js")
    );
    await openInVim(import_coc20.Uri.parse(parserConfigPath), "vsplit");
  }
  async function showUploadedImages() {
    const imageHistoryFilePath = import_mume3.utility.addFileProtocol(
      import_path2.default.resolve((0, import_mume3.getExtensionConfigPath)(), "./image_history.md")
    );
    await openInVim(import_coc20.Uri.parse(imageHistoryFilePath), "vsplit");
  }
  async function cursorPosition() {
    const win = await import_coc20.workspace.nvim.window;
    const cursor = await win.cursor;
    return import_coc20.Position.create(cursor[0], cursor[1]);
  }
  async function insertNewSlide() {
    const doc = await import_coc20.workspace.document;
    await doc.applyEdits([
      import_coc20.TextEdit.insert(await cursorPosition(), "<!-- slide -->\n")
    ]);
  }
  async function insertPagebreak() {
    const doc = await import_coc20.workspace.document;
    await doc.applyEdits([
      import_coc20.TextEdit.insert(await cursorPosition(), "<!-- pagebreak -->\n")
    ]);
  }
  async function createTOC() {
    const doc = await import_coc20.workspace.document;
    await doc.applyEdits([
      import_coc20.TextEdit.insert(
        await cursorPosition(),
        '\n<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->\n'
      )
    ]);
  }
  async function insertTable() {
    const doc = await import_coc20.workspace.document;
    await doc.applyEdits([
      import_coc20.TextEdit.insert(
        await cursorPosition(),
        `|   |   |
|---|---|
|   |   |
`
      )
    ]);
  }
  async function openImageHelper() {
    await contentProvider.openImageHelper(
      import_coc20.Uri.parse((await import_coc20.workspace.document).uri)
    );
  }
  async function webviewFinishLoading(uri, {
    systemColorScheme
  }) {
    const sourceUri = import_coc20.Uri.parse(uri);
    await contentProvider.setSystemColorScheme(systemColorScheme);
    contentProvider.updateMarkdown(sourceUri);
  }
  async function insertImageUrl(uri, imageUrl) {
    const doc = import_coc20.workspace.getDocument(uri);
    if (doc && isMarkdownFile(doc.textDocument)) {
      await doc.applyEdits([
        import_coc20.TextEdit.insert(
          await cursorPosition(),
          `![enter image description here](${imageUrl})`
        )
      ]);
    }
  }
  function refreshPreview(uri) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.refreshPreview(sourceUri);
  }
  function openInBrowser(uri) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.openInBrowser(sourceUri);
  }
  function htmlExport(uri, offline) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.htmlExport(sourceUri, offline);
  }
  function chromeExport(uri, type) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.chromeExport(sourceUri, type);
  }
  function princeExport(uri) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.princeExport(sourceUri);
  }
  function eBookExport(uri, fileType) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.eBookExport(sourceUri, fileType);
  }
  function pandocExport(uri) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.pandocExport(sourceUri);
  }
  function markdownExport(uri) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.markdownExport(sourceUri);
  }
  function cacheCodeChunkResult(uri, id, result) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.cacheCodeChunkResult(sourceUri, id, result);
  }
  function runCodeChunk(uri, codeChunkId) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.runCodeChunk(sourceUri, codeChunkId);
  }
  function runAllCodeChunks(uri) {
    const sourceUri = import_coc20.Uri.parse(uri);
    contentProvider.runAllCodeChunks(sourceUri);
  }
  async function runAllCodeChunksCommand() {
    const doc = await import_coc20.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return;
    }
    const sourceUri = import_coc20.Uri.parse(doc.uri);
    const previewUri = getPreviewUri(sourceUri);
    if (!previewUri) {
      return;
    }
    contentProvider.previewPostMessage(sourceUri, {
      command: "runAllCodeChunks"
    });
  }
  async function runCodeChunkCommand() {
    const doc = await import_coc20.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return;
    }
    const sourceUri = import_coc20.Uri.parse(doc.uri);
    const previewUri = getPreviewUri(sourceUri);
    if (!previewUri) {
      return;
    }
    contentProvider.previewPostMessage(sourceUri, {
      command: "runCodeChunk"
    });
  }
  async function syncPreview() {
    const doc = await import_coc20.workspace.document;
    if (!isMarkdownFile(doc.textDocument)) {
      return;
    }
    const sourceUri = import_coc20.Uri.parse(doc.uri);
    contentProvider.previewPostMessage(sourceUri, {
      command: "changeTextEditorSelection",
      line: (await cursorPosition()).line,
      forced: true
    });
  }
  async function clickTagA(sourceUri, href) {
    const util2 = getWebviewAPI().util;
    const curDoc = await import_coc20.workspace.document;
    href = decodeURIComponent(href);
    if (!href) {
      return;
    }
    const resourceUri = util2.parseResourceUri(href);
    if (resourceUri == null ? void 0 : resourceUri.localPath) {
      const openType = curDoc.uri === sourceUri ? "edit" : "vsplit";
      const hrefUri = import_coc20.Uri.parse(resourceUri.localPath);
      if (!await (0, import_isbinaryfile.isBinaryFile)(hrefUri.fsPath))
        await openInVim(hrefUri, openType);
      return;
    }
    util2.openExternalUri(href);
  }
  async function clickTaskListCheckbox(uri, dataLine) {
    const doc = import_coc20.workspace.getDocument(uri);
    if (!doc || !isMarkdownFile(doc.textDocument)) {
      return;
    }
    const dataLineNum = parseInt(dataLine, 10);
    let line = doc.getline(dataLineNum);
    if (line.match(/\[ \]/)) {
      line = line.replace("[ ]", "[x]");
    } else {
      line = line.replace(/\[[xX]\]/, "[ ]");
    }
    await doc.applyEdits([
      import_coc20.TextEdit.replace(
        import_coc20.Range.create(
          import_coc20.Position.create(dataLineNum, 0),
          import_coc20.Position.create(dataLineNum, line.length)
        ),
        line
      )
    ]);
  }
  async function setPreviewTheme(_uri, theme) {
    const config = import_coc20.workspace.getConfiguration("markdown-preview-enhanced");
    await config.update("previewTheme", theme, true);
  }
  context.subscriptions.push(
    import_coc20.workspace.onDidSaveTextDocument(
      logger.asyncCatch((document) => {
        if (isMarkdownFile(document)) {
          contentProvider.updateMarkdown(import_coc20.Uri.parse(document.uri), true);
        }
      })
    ),
    import_coc20.workspace.onDidChangeTextDocument(
      logger.asyncCatch((event) => {
        const doc = import_coc20.workspace.getDocument(event.textDocument.uri);
        if (doc && isMarkdownFile(doc.textDocument)) {
          contentProvider.update(import_coc20.Uri.parse(doc.uri));
        }
      })
    ),
    import_coc20.workspace.onDidChangeConfiguration(
      logger.asyncCatch(async () => {
        await contentProvider.updateConfiguration();
      })
    ),
    import_coc20.events.on(
      "CursorMoved",
      logger.asyncCatch(async (bufnr) => {
        const doc = import_coc20.workspace.getDocument(bufnr);
        if (doc && isMarkdownFile(doc.textDocument)) {
          if (Date.now() < editorScrollDelay) {
            return;
          }
          const sourceUri = import_coc20.Uri.parse(doc.uri);
          const win = await import_coc20.workspace.nvim.window;
          const height = await win.height;
          if (!height) {
            return void 0;
          }
          const [line] = await win.cursor;
          contentProvider.previewPostMessage(sourceUri, {
            command: "changeTextEditorSelection",
            line
          });
        }
      })
    ),
    /**
     * Open preview automatically if the `automaticallyShowPreviewOfMarkdownBeingEdited` is on.
     * @param textEditor
     */
    import_coc20.events.on(
      "BufEnter",
      logger.asyncCatch(async () => {
        const doc = await import_coc20.workspace.document;
        if (isMarkdownFile(doc.textDocument)) {
          const sourceUri = import_coc20.Uri.parse(doc.uri);
          const config = import_coc20.workspace.getConfiguration("markdown-preview-enhanced");
          const automaticallyShowPreviewOfMarkdownBeingEdited = config.get("automaticallyShowPreviewOfMarkdownBeingEdited");
          const isUsingSinglePreview = config.get("singlePreview");
          if (contentProvider.isPreviewOn(sourceUri)) {
            if (isUsingSinglePreview && !contentProvider.previewHasTheSameSingleSourceUri(sourceUri)) {
              await contentProvider.initPreview(sourceUri, doc, false);
            } else if (!isUsingSinglePreview) {
              const previewPanel = contentProvider.getPreview(sourceUri);
              if (previewPanel) {
                previewPanel.reveal({ openURL: false });
              }
            }
          } else if (automaticallyShowPreviewOfMarkdownBeingEdited) {
            await openPreview(true, sourceUri);
          }
        }
      })
    )
  );
  const registerCommand = (cmd, impl) => import_coc20.commands.registerCommand(cmd, logger.asyncCatch(impl));
  context.subscriptions.push(
    registerCommand(
      "markdown-preview-enhanced.openPreview",
      () => openPreview(true)
    ),
    registerCommand(
      "markdown-preview-enhanced.openPreviewBackground",
      () => openPreview(false)
    ),
    registerCommand(
      "markdown-preview-enhanced.toggleScrollSync",
      toggleScrollSync
    ),
    registerCommand(
      "markdown-preview-enhanced.toggleLiveUpdate",
      toggleLiveUpdate
    ),
    registerCommand(
      "markdown-preview-enhanced.toggleBreakOnSingleNewLine",
      toggleBreakOnSingleNewLine
    ),
    registerCommand(
      "markdown-preview-enhanced.openImageHelper",
      openImageHelper
    ),
    registerCommand(
      "markdown-preview-enhanced.runAllCodeChunks",
      runAllCodeChunksCommand
    ),
    registerCommand(
      "markdown-preview-enhanced.runCodeChunk",
      runCodeChunkCommand
    ),
    registerCommand("markdown-preview-enhanced.syncPreview", syncPreview),
    registerCommand("markdown-preview-enhanced.customizeCss", customizeCSS),
    registerCommand(
      "markdown-preview-enhanced.openMermaidConfig",
      openMermaidConfig
    ),
    registerCommand(
      "markdown-preview-enhanced.openMathJaxConfig",
      openMathJaxConfig
    ),
    registerCommand(
      "markdown-preview-enhanced.openKaTeXConfig",
      openKaTeXConfig
    ),
    registerCommand("markdown-preview-enhanced.extendParser", extendParser),
    registerCommand(
      "markdown-preview-enhanced.showUploadedImages",
      showUploadedImages
    ),
    registerCommand("markdown-preview-enhanced.insertNewSlide", insertNewSlide),
    registerCommand("markdown-preview-enhanced.insertTable", insertTable),
    registerCommand(
      "markdown-preview-enhanced.insertPagebreak",
      insertPagebreak
    ),
    registerCommand("markdown-preview-enhanced.createTOC", createTOC),
    registerCommand("_mume.revealLine", revealLine),
    registerCommand("_mume.insertImageUrl", insertImageUrl),
    registerCommand("_mume.pasteImageFile", pasteImageFile),
    registerCommand("_mume.uploadImageFile", uploadImageFile),
    registerCommand("_mume.refreshPreview", refreshPreview),
    registerCommand("_mume.openInBrowser", openInBrowser),
    registerCommand("_mume.htmlExport", htmlExport),
    registerCommand("_mume.chromeExport", chromeExport),
    registerCommand("_mume.princeExport", princeExport),
    registerCommand("_mume.eBookExport", eBookExport),
    registerCommand("_mume.pandocExport", pandocExport),
    registerCommand("_mume.markdownExport", markdownExport),
    registerCommand("_mume.webviewFinishLoading", webviewFinishLoading),
    // registerCommand('_mume.cacheSVG', cacheSVG),
    registerCommand("_mume.cacheCodeChunkResult", cacheCodeChunkResult),
    registerCommand("_mume.runCodeChunk", runCodeChunk),
    registerCommand("_mume.runAllCodeChunks", runAllCodeChunks),
    registerCommand("_mume.clickTagA", clickTagA),
    registerCommand("_mume.clickTaskListCheckbox", clickTaskListCheckbox),
    registerCommand("_mume.showUploadedImageHistory", showUploadedImages),
    registerCommand("_mume.setPreviewTheme", setPreviewTheme)
  );
}
async function revealLine(uri, line) {
  const doc = import_coc20.workspace.getDocument(uri);
  if (doc && isMarkdownFile(doc.textDocument)) {
    const mode = await import_coc20.workspace.nvim.mode;
    if (mode.mode !== "n") {
      return;
    }
    const sourceLine = Math.min(Math.floor(line), doc.lineCount - 1);
    const fraction = line - sourceLine;
    const text = doc.getline(sourceLine);
    const start = Math.floor(fraction * text.length);
    const winnr = await import_coc20.workspace.nvim.call("bufwinnr", [doc.bufnr]);
    if (winnr === -1)
      return;
    const winid = await import_coc20.workspace.nvim.call("win_getid", [winnr]);
    const win = import_coc20.workspace.nvim.createWindow(winid);
    if (!await win.valid)
      return;
    editorScrollDelay = Date.now() + 500;
    await win.setCursor([sourceLine + 1, start]);
    editorScrollDelay = Date.now() + 500;
  }
}
function deactivate() {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
