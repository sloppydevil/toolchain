import { JsonObject } from 'type-fest';
import * as vscode from 'vscode';
import { CodeChunkData } from './code-chunk-data';
import { MarkdownEngineConfig } from './markdown-engine-config';
export interface MarkdownEngineRenderOption {
    useRelativeFilePath: boolean;
    isForPreview: boolean;
    hideFrontMatter: boolean;
    triggeredBySave?: boolean;
    runAllCodeChunks?: boolean;
    emojiToSvg?: boolean;
    vscodePreviewPanel?: vscode.WebviewPanel | null;
    fileDirectoryPath?: string;
}
export interface MarkdownEngineOutput {
    html: string;
    markdown: string;
    tocHTML: string;
    yamlConfig: JsonObject;
    JSAndCssFiles: string[];
}
export interface HTMLTemplateOption {
    isForPrint: boolean;
    isForPrince: boolean;
    offline: boolean;
    embedLocalImages: boolean;
    embedSVG?: boolean;
}
export declare class MarkdownEngine {
    static modifySource(codeChunkData: CodeChunkData, result: string, filePath: string): Promise<string>;
    static onModifySource(cb: (codeChunkData: CodeChunkData, result: string, filePath: string) => Promise<string>): void;
    private readonly filePath;
    private readonly fileDirectoryPath;
    private readonly projectDirectoryPath;
    private originalConfig;
    private config;
    private breakOnSingleNewLine;
    private enableTypographer;
    private enableLinkify;
    private protocolsWhiteListRegExp;
    private headings;
    private tocHTML;
    private md;
    private vscodePreviewPanel;
    private graphsCache;
    private codeChunksData;
    private filesCache;
    isPreviewInPresentationMode: boolean;
    constructor(args: {
        filePath: string;
        projectDirectoryPath: string;
        config: MarkdownEngineConfig;
    });
    resetConfig(): void;
    private initConfig;
    interpolateConfig(config: MarkdownEngineConfig, projectDirectoryPath: string): void;
    updateConfiguration(config: Partial<MarkdownEngineConfig>): void;
    cacheCodeChunkResult(id: string, result: string): void;
    generateScriptsForPreview(isForPresentation?: boolean, yamlConfig?: {}, vscodePreviewPanel?: vscode.WebviewPanel | null): string;
    private static AutoPrismThemeMap;
    private static AutoPrismThemeMapForPresentation;
    private getPrismTheme;
    generateStylesForPreview(isPresentationMode?: boolean, yamlConfig?: {}, vscodePreviewPanel?: vscode.WebviewPanel | null): string;
    private generateJSAndCssFilesForPreview;
    generateHTMLTemplateForPreview({ inputString, body, webviewScript, scripts, styles, head, config, vscodePreviewPanel, contentSecurityPolicy, }: {
        inputString?: string;
        body?: string;
        webviewScript?: string;
        scripts?: string;
        styles?: string;
        head?: string;
        config: JsonObject;
        vscodePreviewPanel: vscode.WebviewPanel | null | undefined;
        contentSecurityPolicy?: string;
    }): Promise<string>;
    generateHTMLTemplateForExport(html: string, yamlConfig: {} | undefined, options: HTMLTemplateOption): Promise<string>;
    openInBrowser({ runAllCodeChunks }: {
        runAllCodeChunks?: boolean | undefined;
    }): Promise<void>;
    htmlExport({ offline, runAllCodeChunks, }: {
        offline?: boolean | undefined;
        runAllCodeChunks?: boolean | undefined;
    }): Promise<string>;
    chromeExport({ fileType, runAllCodeChunks, openFileAfterGeneration, }: {
        fileType?: string | undefined;
        runAllCodeChunks?: boolean | undefined;
        openFileAfterGeneration?: boolean | undefined;
    }): Promise<string>;
    princeExport({ runAllCodeChunks, openFileAfterGeneration, }: {
        runAllCodeChunks?: boolean | undefined;
        openFileAfterGeneration?: boolean | undefined;
    }): Promise<string>;
    private eBookDownloadImages;
    eBookExport({ fileType, runAllCodeChunks, }: {
        fileType: string;
        runAllCodeChunks?: boolean;
    }): Promise<string>;
    pandocExport({ runAllCodeChunks, openFileAfterGeneration, }: {
        runAllCodeChunks?: boolean | undefined;
        openFileAfterGeneration?: boolean | undefined;
    }): Promise<string>;
    markdownExport({ runAllCodeChunks }: {
        runAllCodeChunks?: boolean | undefined;
    }): Promise<string>;
    private exportOnSave;
    private resolveFilePath;
    clearCaches(): void;
    private frontMatterToTable;
    private processFrontMatter;
    private parseSlides;
    pandocRender(text: string | undefined, args: string[]): Promise<string>;
    parseMD(inputString: string, options: MarkdownEngineRenderOption): Promise<MarkdownEngineOutput>;
    runCodeChunks(): Promise<string[]>;
    runCodeChunk(id: string): Promise<string>;
    private generateRunOptions;
}
