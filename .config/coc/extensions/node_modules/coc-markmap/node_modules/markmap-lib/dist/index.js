"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const remarkable = require("remarkable");
const markmapCommon = require("markmap-common");
const remarkableKatex = require("remarkable-katex");
const yaml = require("js-yaml");
const hljs = require("highlight.js");
const template = '<!DOCTYPE html>\n<html>\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n<meta http-equiv="X-UA-Compatible" content="ie=edge">\n<title>Markmap</title>\n<style>\n* {\n  margin: 0;\n  padding: 0;\n}\n#mindmap {\n  display: block;\n  width: 100vw;\n  height: 100vh;\n}\n</style>\n<!--CSS-->\n</head>\n<body>\n<svg id="mindmap"></svg>\n<!--JS-->\n</body>\n</html>\n';
const baseJsPaths = [
  `d3@${"7.8.5"}/dist/d3.min.js`,
  `markmap-view@${"0.15.8"}/dist/browser/index.js`
];
const name$3 = "katex";
const preloadScripts$1 = [
  `katex@${"0.16.8"}/dist/katex.min.js`
].map((path) => markmapCommon.buildJSItem(path));
const webfontloader = markmapCommon.buildJSItem(
  `webfontloader@${"1.6.28"}/webfontloader.js`
);
webfontloader.data.defer = true;
const styles$1 = [`katex@${"0.16.8"}/dist/katex.min.css`].map(
  (path) => markmapCommon.buildCSSItem(path)
);
const config$1 = {
  versions: {
    katex: "0.16.8",
    webfontloader: "1.6.28"
  },
  preloadScripts: preloadScripts$1,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (getMarkmap) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              getMarkmap().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap }) {
          return [getMarkmap];
        }
      }
    },
    webfontloader
  ],
  styles: styles$1
};
function createTransformHooks(transformer) {
  return {
    transformer,
    parser: new markmapCommon.Hook(),
    beforeParse: new markmapCommon.Hook(),
    afterParse: new markmapCommon.Hook(),
    htmltag: new markmapCommon.Hook(),
    retransform: new markmapCommon.Hook()
  };
}
function definePlugin(plugin2) {
  return plugin2;
}
const plugin$1 = definePlugin({
  name: name$3,
  config: config$1,
  transform(transformHooks) {
    var _a, _b;
    let enableFeature = markmapCommon.noop;
    transformHooks.parser.tap((md) => {
      md.use(remarkableKatex);
      md.renderer.rules.katex = markmapCommon.wrapFunction(
        md.renderer.rules.katex,
        (render, ...args) => {
          enableFeature();
          return render(...args);
        }
      );
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$3] = true;
      };
    });
    return {
      styles: (_a = plugin$1.config) == null ? void 0 : _a.styles,
      scripts: (_b = plugin$1.config) == null ? void 0 : _b.scripts
    };
  }
});
const name$2 = "frontmatter";
const frontmatter = definePlugin({
  name: name$2,
  transform(transformHooks) {
    transformHooks.beforeParse.tap((md, context) => {
      const { content } = context;
      if (!/^---\r?\n/.test(content))
        return;
      const match = /\n---\r?\n/.exec(content);
      if (!match)
        return;
      const raw = content.slice(4, match.index);
      let frontmatter2;
      try {
        frontmatter2 = yaml.load(raw);
        if (frontmatter2 == null ? void 0 : frontmatter2.markmap) {
          frontmatter2.markmap = normalizeMarkmapJsonOptions(
            frontmatter2.markmap
          );
        }
      } catch {
        return;
      }
      context.frontmatter = frontmatter2;
      context.content = content.slice(match.index + match[0].length);
      context.contentLineOffset = content.slice(0, match.index).split("\n").length + 1;
    });
    return {};
  }
});
function normalizeMarkmapJsonOptions(options) {
  if (!options)
    return;
  ["color", "extraJs", "extraCss"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeStringArray(options[key]);
  });
  ["duration", "maxWidth", "initialExpandLevel"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeNumber(options[key]);
  });
  return options;
}
function normalizeStringArray(value) {
  let result;
  if (typeof value === "string")
    result = [value];
  else if (Array.isArray(value))
    result = value.filter((item) => item && typeof item === "string");
  return (result == null ? void 0 : result.length) ? result : void 0;
}
function normalizeNumber(value) {
  if (isNaN(+value))
    return;
  return +value;
}
const name$1 = "npmUrl";
const npmUrl = definePlugin({
  name: name$1,
  transform(transformHooks) {
    transformHooks.afterParse.tap((_, context) => {
      const { frontmatter: frontmatter2 } = context;
      const markmap = frontmatter2 == null ? void 0 : frontmatter2.markmap;
      if (markmap) {
        ["extraJs", "extraCss"].forEach((key) => {
          const value = markmap[key];
          if (value) {
            markmap[key] = value.map((path) => {
              if (path.startsWith("npm:")) {
                return transformHooks.transformer.urlBuilder.getFullUrl(
                  path.slice(4)
                );
              }
              return path;
            });
          }
        });
      }
    });
    return {};
  }
});
const name = "hljs";
const preloadScripts = [
  `@highlightjs/cdn-assets@${"11.8.0"}/highlight.min.js`
].map((path) => markmapCommon.buildJSItem(path));
const styles = [
  `@highlightjs/cdn-assets@${"11.8.0"}/styles/default.min.css`
  // `highlight.js@${process.env.HLJS_VERSION}/styles/default.css`,
].map((path) => markmapCommon.buildCSSItem(path));
const config = {
  versions: {
    hljs: "11.8.0"
  },
  preloadScripts,
  styles
};
const plugin = definePlugin({
  name,
  config,
  transform(transformHooks) {
    var _a;
    let enableFeature = markmapCommon.noop;
    transformHooks.parser.tap((md) => {
      md.set({
        highlight: (str, language) => {
          enableFeature();
          return hljs.highlightAuto(str, language ? [language] : void 0).value;
        }
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name] = true;
      };
    });
    return {
      styles: (_a = plugin.config) == null ? void 0 : _a.styles
    };
  }
});
const plugins = [frontmatter, plugin$1, plugin, npmUrl];
function patchJSItem(urlBuilder, item) {
  if (item.type === "script" && item.data.src) {
    return {
      ...item,
      data: {
        ...item.data,
        src: urlBuilder.getFullUrl(item.data.src)
      }
    };
  }
  return item;
}
function patchCSSItem(urlBuilder, item) {
  if (item.type === "stylesheet" && item.data.href) {
    return {
      ...item,
      data: {
        ...item.data,
        href: urlBuilder.getFullUrl(item.data.href)
      }
    };
  }
  return item;
}
function cleanNode(node) {
  var _a, _b;
  if (node.type === "heading") {
    node.children = node.children.filter((item) => item.type !== "paragraph");
  } else if (node.type === "list_item") {
    node.children = node.children.filter((item) => {
      if (["paragraph", "fence"].includes(item.type)) {
        if (!node.content) {
          node.content = item.content;
          node.payload = {
            ...node.payload,
            ...item.payload
          };
        }
        return false;
      }
      return true;
    });
    if (((_a = node.payload) == null ? void 0 : _a.index) != null) {
      node.content = `${node.payload.index}. ${node.content}`;
    }
  } else if (node.type === "ordered_list") {
    let index = ((_b = node.payload) == null ? void 0 : _b.startIndex) ?? 1;
    node.children.forEach((item) => {
      if (item.type === "list_item") {
        item.payload = {
          ...item.payload,
          index
        };
        index += 1;
      }
    });
  }
  if (node.children.length > 0) {
    node.children.forEach((child) => cleanNode(child));
    if (node.children.length === 1 && !node.children[0].content) {
      node.children = node.children[0].children;
    }
  }
}
function resetDepth(node, depth = 0) {
  node.depth = depth;
  node.children.forEach((child) => {
    resetDepth(child, depth + 1);
  });
}
class Transformer {
  constructor(plugins$1 = plugins) {
    this.assetsMap = {};
    this.urlBuilder = new markmapCommon.UrlBuilder();
    this.hooks = createTransformHooks(this);
    this.plugins = plugins$1.map(
      (plugin2) => typeof plugin2 === "function" ? plugin2() : plugin2
    );
    const assetsMap = {};
    for (const { name: name2, transform } of this.plugins) {
      assetsMap[name2] = transform(this.hooks);
    }
    this.assetsMap = assetsMap;
    const md = new remarkable.Remarkable("full", {
      html: true,
      breaks: true,
      maxNesting: Infinity
    });
    md.renderer.rules.htmltag = markmapCommon.wrapFunction(
      md.renderer.rules.htmltag,
      (render, ...args) => {
        const result = render(...args);
        this.hooks.htmltag.call({ args, result });
        return result;
      }
    );
    this.md = md;
    this.hooks.parser.call(md);
  }
  buildTree(tokens) {
    const { md } = this;
    const root = {
      type: "root",
      depth: 0,
      content: "",
      children: [],
      payload: {}
    };
    const stack = [root];
    let depth = 0;
    for (const token of tokens) {
      const payload = {};
      if (token.lines) {
        payload.lines = token.lines;
      }
      let current = stack[stack.length - 1];
      if (token.type.endsWith("_open")) {
        const type = token.type.slice(0, -5);
        if (type === "heading") {
          depth = token.hLevel;
          while ((current == null ? void 0 : current.depth) >= depth) {
            stack.pop();
            current = stack[stack.length - 1];
          }
        } else {
          depth = Math.max(depth, (current == null ? void 0 : current.depth) || 0) + 1;
          if (type === "ordered_list") {
            payload.startIndex = token.order;
          }
        }
        const item = {
          type,
          depth,
          payload,
          content: "",
          children: []
        };
        current.children.push(item);
        stack.push(item);
      } else if (!current) {
        continue;
      } else if (token.type === `${current.type}_close`) {
        if (current.type === "heading") {
          depth = current.depth;
        } else {
          stack.pop();
          depth = 0;
        }
      } else if (token.type === "inline") {
        const revoke = this.hooks.htmltag.tap((ctx) => {
          var _a;
          const comment = (_a = ctx.result) == null ? void 0 : _a.match(/^<!--([\s\S]*?)-->$/);
          const data = comment == null ? void 0 : comment[1].trim().split(" ");
          if ((data == null ? void 0 : data[0]) === "fold") {
            current.payload = {
              ...current.payload,
              fold: ["all", "recursively"].includes(data[1]) ? 2 : 1
            };
            ctx.result = "";
          }
        });
        const text = md.renderer.render([token], md.options, {});
        revoke();
        current.content = `${current.content || ""}${text}`;
      } else if (token.type === "fence") {
        const result = md.renderer.render([token], md.options, {});
        current.children.push({
          type: token.type,
          depth: depth + 1,
          content: result,
          children: [],
          payload
        });
      } else
        ;
    }
    return root;
  }
  transform(content) {
    var _a;
    const context = {
      content,
      features: {},
      contentLineOffset: 0
    };
    this.hooks.beforeParse.call(this.md, context);
    const tokens = this.md.parse(context.content, {});
    this.hooks.afterParse.call(this.md, context);
    let root = this.buildTree(tokens);
    cleanNode(root);
    if (((_a = root.children) == null ? void 0 : _a.length) === 1)
      root = root.children[0];
    resetDepth(root);
    return { ...context, root };
  }
  /**
   * Get all assets from enabled plugins or filter them by plugin names as keys.
   */
  getAssets(keys) {
    const styles2 = [];
    const scripts = [];
    keys ?? (keys = this.plugins.map((plugin2) => plugin2.name));
    for (const assets of keys.map((key) => this.assetsMap[key])) {
      if (assets) {
        if (assets.styles)
          styles2.push(...assets.styles);
        if (assets.scripts)
          scripts.push(...assets.scripts);
      }
    }
    return {
      styles: styles2.map((item) => patchCSSItem(this.urlBuilder, item)),
      scripts: scripts.map((item) => patchJSItem(this.urlBuilder, item))
    };
  }
  /**
   * Get used assets by features object returned by `transform`.
   */
  getUsedAssets(features) {
    const keys = this.plugins.map((plugin2) => plugin2.name).filter((name2) => features[name2]);
    return this.getAssets(keys);
  }
  fillTemplate(root, assets, extra) {
    extra = {
      ...extra
    };
    extra.baseJs ?? (extra.baseJs = baseJsPaths.map((path) => this.urlBuilder.getFullUrl(path)).map((path) => markmapCommon.buildJSItem(path)));
    const { scripts, styles: styles2 } = assets;
    const cssList = [...styles2 ? markmapCommon.persistCSS(styles2) : []];
    const context = {
      getMarkmap: () => window.markmap,
      getOptions: extra.getOptions,
      jsonOptions: extra.jsonOptions,
      root
    };
    const jsList = [
      ...markmapCommon.persistJS(
        [
          ...extra.baseJs,
          ...scripts || [],
          {
            type: "iife",
            data: {
              fn: (getMarkmap, getOptions, root2, jsonOptions) => {
                const markmap = getMarkmap();
                window.mm = markmap.Markmap.create(
                  "svg#mindmap",
                  (getOptions || markmap.deriveOptions)(jsonOptions),
                  root2
                );
              },
              getParams: ({ getMarkmap, getOptions, root: root2, jsonOptions }) => {
                return [getMarkmap, getOptions, root2, jsonOptions];
              }
            }
          }
        ],
        context
      )
    ];
    const html = template.replace("<!--CSS-->", () => cssList.join("")).replace("<!--JS-->", () => jsList.join(""));
    return html;
  }
}
const transformerVersions = {
  "markmap-lib": "process.env.VERSION",
  d3: "7.8.5"
};
exports.Transformer = Transformer;
exports.baseJsPaths = baseJsPaths;
exports.builtInPlugins = plugins;
exports.template = template;
exports.transformerVersions = transformerVersions;
